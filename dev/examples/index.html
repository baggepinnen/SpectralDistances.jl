<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SpectralDistances</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralDistances</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Typical-workflows"><span>Typical workflows</span></a></li><li><a class="tocitem" href="#Nearest-Neighbor-classification"><span>Nearest Neighbor classification</span></a></li><li><a class="tocitem" href="#Pairwise-distance-matrix"><span>Pairwise distance matrix</span></a></li><li><a class="tocitem" href="#Detection-using-examples"><span>Detection using examples</span></a></li><li><a class="tocitem" href="#Computing-a-spectrogram-distance-profile"><span>Computing a spectrogram distance profile</span></a></li><li><a class="tocitem" href="#The-closed-form-solution"><span>The closed-form solution</span></a></li></ul></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Typical-workflows"><a class="docs-heading-anchor" href="#Typical-workflows">Typical workflows</a><a id="Typical-workflows-1"></a><a class="docs-heading-anchor-permalink" href="#Typical-workflows" title="Permalink"></a></h2><p>In this section, we&#39;ll demonstrate some common ways of interacting with the package</p><p>To quickly try things out, you can generate some example models of signals using <a href="../ltimodels/#SpectralDistances.examplemodels"><code>examplemodels</code></a> like this <code>models = examplemodels(10)</code>.</p><h3 id="Calculate-root-embeddings-from-sound-files"><a class="docs-heading-anchor" href="#Calculate-root-embeddings-from-sound-files">Calculate root embeddings from sound files</a><a id="Calculate-root-embeddings-from-sound-files-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-root-embeddings-from-sound-files" title="Permalink"></a></h3><p>In this example, we&#39;ll read a bunch of sound files and calculate embedding vectors containing information about the poles of estimated rational spectra. These embeddings are useful for classification etc. See the paper for further explanation.</p><p>This example makes use of a few other packages, notably <a href="https://github.com/baggepinnen/AudioClustering.jl">AudioClustering.jl</a> for some convenience functions.</p><pre><code class="language-julia hljs">using Glob, WAV, SpectralDistances
const fs = 44100
using Grep
##
using DSP, LPVSpectral
using AudioClustering

path = &quot;path/to/folder/with/wav-files&quot;

cd(path)
files     = glob(&quot;*.wav&quot;)
labels0   = match.(r&quot;[a-z_]+&quot;, files)..:match .|&gt; String # This regex assumes that the files are named in a certain way, you may adopt as needed, or load the labels separately.
ulabels   = unique(labels0)
n_classes = length(ulabels)
labels    = sum((labels0 .== reshape(ulabels,1,:)) .* (1:n_classes)&#39;, dims=2)[:]
na        = 18 # Order of the models (prefer an even number)
fitmethod = LS(na=na, λ=1e-5)
fs        = 44100 # the sample rate

models = mapsoundfiles(files, fs) do sound # mapsoundfiles is defined in AudioClustering
    sound = SpectralDistances.bp_filter(sound, (50/fs, 18000/fs)) # prefiltering is a good idea
    SpectralDistances.fitmodel(fitmethod, sound)
end

X = embeddings(models)</code></pre><p>We now have a matrix <code>X</code> with features, we can run clustering on it like this:</p><pre><code class="language-julia hljs">using Clustering
labels,models,X,Z = get_features(trainpath)
cr = kmeans(v1(X,2), n_classes) # v1 normalizes mean and variance

Plots.plot(
    scatter(threeD(X&#39;),
        marker_z          = labels,
        m                 = (2, 0.5),
        markerstrokealpha = 0,
        colorbar          = false,
        title             = &quot;Correct assignment&quot;,
    ),
    scatter(threeD(X&#39;),
        marker_z          = cr.assignments,
        m                 = (2, 0.5),
        markerstrokealpha = 0,
        colorbar          = false,
        title             = &quot;K-means on w assignment&quot;,
    ),
    legend = false,
)</code></pre><p>Another clustering approach is to use <a href="../interpolations/#SpectralDistances.kbarycenters-Tuple{Any, Any, Any}"><code>kbarycenters</code></a>, see example <a href="../interpolations/#K-Barycenters">K-Barycenters</a>.</p><h2 id="Nearest-Neighbor-classification"><a class="docs-heading-anchor" href="#Nearest-Neighbor-classification">Nearest Neighbor classification</a><a id="Nearest-Neighbor-classification-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-Neighbor-classification" title="Permalink"></a></h2><h3 id="Using-embeddings"><a class="docs-heading-anchor" href="#Using-embeddings">Using embeddings</a><a id="Using-embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Using-embeddings" title="Permalink"></a></h3><p>Here, we will classify a signal based on it&#39;s nearest neighbor in a training dataset. The example assumes that the matrix <code>X</code> from the previous example is available, and that there is a similar matrix <code>Xt</code> created from a test dataset. We will classify the entries in the test set using the entries in the training set. The example also assumes that there are two vectors <code>labels::Vector{Int}</code> and <code>labelst::Vector{Int}</code> that contain the class labels.</p><pre><code class="language-julia hljs">using AMD # For permutation of the confusion matrix to more easily identity similar classes.
using MultivariateStats # For whitening transform

function knn_classify(labels, X, Xt, k)
    N    = size(Xt,2)
    y    = zeros(Int, N)
    W    = fit(Whitening, X)
    X    = MultivariateStats.transform(W,X)
    Xt   = MultivariateStats.transform(W,Xt)
    tree = NearestNeighbors.KDTree(X)
    for i in 1:N
        inds, dists = knn(tree, Xt[:,i], k)
        y[i]        = mode(labels[inds])
    end
    y
end

yht = knn_classify(labels,X,Xt,1) # look at the single nearest neighbor
@show mean(labelst .== yht) # This is the accuracy
cm   = confusmat(30,labelst,yht)
perm = amd(sparse(cm))
cm   = cm[perm,perm]
heatmap(cm./sum(cm,dims=2), xlabel=&quot;Predicted class&quot;,ylabel=&quot;True class&quot;, title=&quot;Confusion Matrix for Test Data&quot;)
anns = [(reverse(ci.I)..., text(val,8)) for (ci,val) in zip(CartesianIndices(cm)[:], vec(cm))]
annotate!(anns)</code></pre><h3 id="Using-spectrograms"><a class="docs-heading-anchor" href="#Using-spectrograms">Using spectrograms</a><a id="Using-spectrograms-1"></a><a class="docs-heading-anchor-permalink" href="#Using-spectrograms" title="Permalink"></a></h3><p>See <a href="https://github.com/baggepinnen/AudioClustering.jl#spectrogram-based">AudioClustering docs</a> for instructions on how to preprocess data for spectrogram-based clustering. When a number of spectrogram patterns are available, the following function may be used to classify spectrograms in <code>X</code> according to <code>patterns</code>.</p><p>A suitable distance for this classification is</p><pre><code class="language-julia hljs">using DynamicAxisWarping
normalizer = NormNormalizer
d = DTW(radius=4, dist = Euclidean(), transportcost=1.005, normalizer=normalizer)</code></pre><p>When a number of spectrogram patterns are available, the following function may be used to classify spectrograms in <code>X</code> according to <code>patterns</code>.</p><pre><code class="language-julia hljs">@time labels, D = AudioClustering.pattern_classify(d, patterns, X)</code></pre><h2 id="Pairwise-distance-matrix"><a class="docs-heading-anchor" href="#Pairwise-distance-matrix">Pairwise distance matrix</a><a id="Pairwise-distance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Pairwise-distance-matrix" title="Permalink"></a></h2><p>Many algorithms make use of a matrix containing all pairwise distances between points. Given a set of models, we can easily obtain such a matrix:</p><pre><code class="language-julia hljs">distance = OptimalTransportRootDistance(domain=Continuous())
D = SpectralDistances.distmat(distance, models, normalize=true)</code></pre><p>with this matrix, we can, for instance, run clustering:</p><pre><code class="language-julia hljs">using Clustering
cr = hclust(Symmetric(sqrt.(D)))
assignments = cutree(cr,k=30) # k is desired number of clusters</code></pre><p>Another clustering approach is to use <a href="../interpolations/#SpectralDistances.kbarycenters-Tuple{Any, Any, Any}"><code>kbarycenters</code></a>, see example in the docstring.</p><h4 id="Fill-in-an-uncomplete-distance-matrix"><a class="docs-heading-anchor" href="#Fill-in-an-uncomplete-distance-matrix">Fill in an uncomplete distance matrix</a><a id="Fill-in-an-uncomplete-distance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Fill-in-an-uncomplete-distance-matrix" title="Permalink"></a></h4><p>The function <a href="../distances/#SpectralDistances.complete_distmat"><code>complete_distmat</code></a> takes a distance matrix with missing entries and reconstructs the full matrix. This can be useful if the distances in <code>D</code> are noisy and not all of them are available, such as in a microphone calibration problem.</p><h2 id="Detection-using-examples"><a class="docs-heading-anchor" href="#Detection-using-examples">Detection using examples</a><a id="Detection-using-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Detection-using-examples" title="Permalink"></a></h2><p>A measure of distance can be used for detection, by selecting a few positive examples and calculating the distance to the nearest neighbor within these examples from a new query point, a simple example:</p><pre><code class="language-julia hljs">function scorefunction(query_model)
    distance = OptimalTransportRootDistance(domain=Continuous())
    distance_vector = distance.(Ref(query_model),positive_example_models)
    score = minimum(distance_vector)
end</code></pre><p>This can be made significantly more effective (but less accurate) using the <code>knn</code>  approach from the <a href="#Nearest-Neighbor-classification">Nearest Neighbor classification</a>. If you want to detect a small number of patterns in a much longer signal, see the method using <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{var&quot;#s976&quot;, T} where {var&quot;#s976&quot;&lt;:OptimalTransportRootDistance, T}, TimeVaryingAR, TimeVaryingAR}"><code>SlidingDistancesBase.distance_profile</code></a> below.</p><h2 id="Computing-a-spectrogram-distance-profile"><a class="docs-heading-anchor" href="#Computing-a-spectrogram-distance-profile">Computing a spectrogram distance profile</a><a id="Computing-a-spectrogram-distance-profile-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-a-spectrogram-distance-profile" title="Permalink"></a></h2><p>In this example, we&#39;ll search through a long spectrogram <code>Y</code> for a short query <code>Q</code>. We will compute a <em>distance profile</em>, which is a vector with all distance between <code>Q</code> and each window into <code>Y</code> of the same length as <code>Q</code>. The distance profile should have minima roughly where <code>Y</code> has the same frequencies as the query, and the global minimum where the chirp has increasing frequency (you can zoon into the figure to verify).</p><p>To make computing distance profiles faster, <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{var&quot;#s976&quot;, T} where {var&quot;#s976&quot;&lt;:OptimalTransportRootDistance, T}, TimeVaryingAR, TimeVaryingAR}"><code>SlidingDistancesBase.distance_profile</code></a> accepts a <code>stride</code>. We also set <code>β</code> relatively high to get a smooth and noise-free distance profile.</p><pre><code class="language-julia hljs">using SpectralDistances, DSP, Plots
Q = spectrogram(
    sin.(LinRange(0.9, 1.1, 10000).^ 2 .* (1:10000)) .+ 0.1 * randn(10000),
    256,
    window = hanning,
)
Y = spectrogram(
    sin.(LinRange(0.7, 1.6, 300_000).^ 2 .* (1:300_000)) .+ 0.01 * randn(300_000),
    256,
    window = hanning,
)

d = ConvOptimalTransportDistance(β=0.05, dynamic_floor=-3.0)
D = distance_profile(d, Q, Y, tol=1e-6, stride=15)
plot(
    plot(Y, title = &quot;Data&quot;),
    plot(Q, title = &quot;Query spectrogram&quot;),
    plot(D, title = &quot;Distance Profile&quot;),
    legend = false,
    colorbar = false,
)</code></pre><object type="text/html" data="../dist_profile.html" style="width:100%;height:450px;"></object><p>To illustrate the effect of setting <code>invariant_axis = 2</code>, i.e., configuring the distance to be approximately invariant to translations along the time axis, we conpute two different distance profiles</p><pre><code class="language-julia hljs">using SpectralDistances, DSP, Plots
N = 48_000
g(x,N) = exp(-10*(x-N/2)^2/N^2)
t = 1:N
f = range(0.01, stop=1, length=N)
y = sin.(t .* f) .* g.(t, N)
y1 = y .+ 0.1 .* randn.()
y2 = [0y; y; 0y] .+ 0.1 .* randn.()

Q = spectrogram(y1, 512, window = hanning)
Y = spectrogram(y2, 512, window = hanning)

d = ConvOptimalTransportDistance(β=0.01, dynamic_floor=-3.0)
D = distance_profile(d, Q, Y, tol=1e-6, stride=15)

di = ConvOptimalTransportDistance(β=0.01, dynamic_floor=-3.0, invariant_axis=2)
Di = distance_profile(di, Q, Y, tol=1e-6, stride=15)

plot(
    plot(Y, title = &quot;Data&quot;, legend = false, xlabel=&quot;&quot;),
    plot(Q, title = &quot;Query spectrogram&quot;, legend = false, xlabel=&quot;&quot;),
    plot([D Di], title = &quot;Distance Profile&quot;, lab=[&quot;Regular&quot; &quot;Invariant time axis&quot;]),
    colorbar = false,
    layout = (1,3)
)</code></pre><object type="text/html" data="../dist_profile_invariant.html" style="width:100%;height:450px;"></object><p>It should be obvious from the distance profiles that the one corresponding to the distance with an invariant axis is less sensitve to purturbations along the time axis. Both distance profiles should have roughly the same global minimum, and they should also be similar when there is no overlap between <code>Q</code> and <code>Y</code>. However, when there&#39;s a partial overlap, the invariant distance is smaller.</p><h2 id="The-closed-form-solution"><a class="docs-heading-anchor" href="#The-closed-form-solution">The closed-form solution</a><a id="The-closed-form-solution-1"></a><a class="docs-heading-anchor-permalink" href="#The-closed-form-solution" title="Permalink"></a></h2><p>In this example we will simply visualize two spectra, the locations of their poles and the cumulative spectrum functions.</p><pre><code class="language-julia hljs">using ControlSystemsBase, SpectralDistances, Plots
plotly(grid=false)

G1   = tf(1,[1,0.12,1])*tf(1,[1,0.1,0.1])
G2   = tf(1,[1,0.12,2])*tf(1,[1,0.1,0.4])
a1   = denvec(G1)[]
a2   = denvec(G2)[]
n    = length(a1)

f1c  = w -&gt; abs2(1/sum(j-&gt;a1[j]*(im*w)^(n-j), 1:n))
f2c  = w -&gt; abs2(1/sum(j-&gt;a2[j]*(im*w)^(n-j), 1:n))
sol1 = SpectralDistances.c∫(f1c,0,3π)
sol2 = SpectralDistances.c∫(f2c,0,3π)

fig1 = plot((sol1.t .+ sol1.t[2]).*2π, sqrt.(sol1 ./ sol1[end]).u, fillrange=sqrt.(sol2(sol1.t) ./ sol2[end]).u, fill=(0.6,:purple), l=(2,:blue))
plot!((sol2.t .+ sol2.t[2]).*2π, sqrt.(sol2(sol2.t) ./ sol2[end]).u, l=(2,:orange), xscale=:log10, legend=false, grid=false, xlabel=&quot;Frequency&quot;, xlims=(1e-2,2pi))

fig2 = bodeplot([G1, G2], exp10.(LinRange(-1.5, 1, 200)), legend=false, grid=false, title=&quot;&quot;, linecolor=[:blue :orange], l=(2,), plotphase=false)

fig3 = pzmap([G1, G2], legend=false, grid=false, title=&quot;&quot;, markercolor=[:blue :orange], color=[:blue :orange], m=(2,:c), xlims=(-0.5,0.5))
vline!([0], l=(:black, :dash))
hline!([0], l=(:black, :dash))

plot(fig1, fig2, fig3, layout=(1,3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Spectral integration failed, increasing precision
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/losses.jl:827
┌ Warning: Spectral integration failed, increasing precision
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/losses.jl:827</code></pre><object type="text/html" data="../cumulative.html" style="width:100%;height:450px;"></object></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../misc/">« Misc.</a><a class="docs-footer-nextpage" href="../taskview/">Task View »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 26 November 2022 09:37">Saturday 26 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
