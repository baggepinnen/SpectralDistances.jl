<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Typical-workflows-1"><span>Typical workflows</span></a></li><li><a class="tocitem" href="#Nearest-Neighbor-classification-1"><span>Nearest Neighbor classification</span></a></li><li><a class="tocitem" href="#Pairwise-distance-matrix-1"><span>Pairwise distance matrix</span></a></li><li><a class="tocitem" href="#Detection-using-examples-1"><span>Detection using examples</span></a></li><li><a class="tocitem" href="#Computing-a-spectrogram-distance-profile-1"><span>Computing a spectrogram distance profile</span></a></li><li><a class="tocitem" href="#The-closed-form-solution-1"><span>The closed-form solution</span></a></li></ul></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h1><h2 id="Typical-workflows-1"><a class="docs-heading-anchor" href="#Typical-workflows-1">Typical workflows</a><a class="docs-heading-anchor-permalink" href="#Typical-workflows-1" title="Permalink"></a></h2><p>In this section, we&#39;ll demonstrate some common ways of interacting with the package</p><p>To quickly try things out, you can generate some example models of signals using <a href="../ltimodels/#SpectralDistances.examplemodels"><code>examplemodels</code></a> like this <code>models = examplemodels(10)</code>.</p><h3 id="Calculate-root-embeddings-from-sound-files-1"><a class="docs-heading-anchor" href="#Calculate-root-embeddings-from-sound-files-1">Calculate root embeddings from sound files</a><a class="docs-heading-anchor-permalink" href="#Calculate-root-embeddings-from-sound-files-1" title="Permalink"></a></h3><p>In this example, we&#39;ll read a bunch of sound files and calculate embedding vectors containing information about the poles of estimated rational spectra. These embeddings are useful for classification etc. See the paper for further explanation.</p><p>This example makes use of a few other packages, notably <a href="https://github.com/baggepinnen/AudioClustering.jl">AudioClustering.jl</a> for some convenience functions.</p><pre><code class="language-julia">using Glob, WAV, SpectralDistances
const fs = 44100
using Grep
##
using DSP, LPVSpectral
using AudioClustering

path = &quot;path/to/folder/with/wav-files&quot;

cd(path)
files     = glob(&quot;*.wav&quot;)
labels0   = match.(r&quot;[a-z_]+&quot;, files)..:match .|&gt; String # This regex assumes that the files are named in a certain way, you may adopt as needed, or load the labels separately.
ulabels   = unique(labels0)
n_classes = length(ulabels)
labels    = sum((labels0 .== reshape(ulabels,1,:)) .* (1:n_classes)&#39;, dims=2)[:]
na        = 18 # Order of the models (prefer an even number)
fitmethod = LS(na=na, λ=1e-5)
fs        = 44100 # the sample rate

models = mapsoundfiles(files, fs) do sound # mapsoundfiles is defined in AudioClustering
    sound = SpectralDistances.bp_filter(sound, (50/fs, 18000/fs)) # prefiltering is a good idea
    SpectralDistances.fitmodel(fitmethod, sound)
end

X = embeddings(models)</code></pre><p>We now have a matrix <code>X</code> with features, we can run clustering on it like this:</p><pre><code class="language-julia">using Clustering
labels,models,X,Z = get_features(trainpath)
cr = kmeans(v1(X,2), n_classes) # v1 normalizes mean and variance

Plots.plot(
    scatter(threeD(X&#39;),
        marker_z          = labels,
        m                 = (2, 0.5),
        markerstrokealpha = 0,
        colorbar          = false,
        title             = &quot;Correct assignment&quot;,
    ),
    scatter(threeD(X&#39;),
        marker_z          = cr.assignments,
        m                 = (2, 0.5),
        markerstrokealpha = 0,
        colorbar          = false,
        title             = &quot;K-means on w assignment&quot;,
    ),
    legend = false,
)</code></pre><p>Another clustering approach is to use <a href="../interpolations/#SpectralDistances.kbarycenters-Tuple{Any,Any,Any}"><code>kbarycenters</code></a>, see example <a href="../interpolations/#K-Barycenters-1">K-Barycenters</a>.</p><h2 id="Nearest-Neighbor-classification-1"><a class="docs-heading-anchor" href="#Nearest-Neighbor-classification-1">Nearest Neighbor classification</a><a class="docs-heading-anchor-permalink" href="#Nearest-Neighbor-classification-1" title="Permalink"></a></h2><p>Here, we will classify a signal based on it&#39;s nearest neighbor in a training dataset. The example assumes that the matrix <code>X</code> from the previous example is available, and that there is a similar matrix <code>Xt</code> created from a test dataset. We will classify the entries in the test set using the entries in the training set. The example also assumes that there are two vectors <code>labels::Vector{Int}</code> and <code>labelst::Vector{Int}</code> that contain the class labels.</p><pre><code class="language-julia">using AMD # For permutation of the confusion matrix to more easily identity similar classes.
using MultivariateStats # For whitening transform

function knn_classify(labels, X, Xt, k)
    N    = size(Xt,2)
    y    = zeros(Int, N)
    W    = fit(Whitening, X)
    X    = MultivariateStats.transform(W,X)
    Xt   = MultivariateStats.transform(W,Xt)
    tree = NearestNeighbors.KDTree(X)
    for i in 1:N
        inds, dists = knn(tree, Xt[:,i], k)
        y[i]        = mode(labels[inds])
    end
    y
end

yht = knn_classify(labels,X,Xt,1) # look at the single nearest neighbor
@show mean(labelst .== yht) # This is the accuracy
cm   = confusmat(30,labelst,yht)
perm = amd(sparse(cm))
cm   = cm[perm,perm]
heatmap(cm./sum(cm,dims=2), xlabel=&quot;Predicted class&quot;,ylabel=&quot;True class&quot;, title=&quot;Confusion Matrix for Test Data&quot;)
anns = [(reverse(ci.I)..., text(val,8)) for (ci,val) in zip(CartesianIndices(cm)[:], vec(cm))]
annotate!(anns)</code></pre><h2 id="Pairwise-distance-matrix-1"><a class="docs-heading-anchor" href="#Pairwise-distance-matrix-1">Pairwise distance matrix</a><a class="docs-heading-anchor-permalink" href="#Pairwise-distance-matrix-1" title="Permalink"></a></h2><p>Many algorithms make use of a matrix containing all pairwise distances between points. Given a set of models, we can easily obtain such a matrix:</p><pre><code class="language-julia">distance = OptimalTransportRootDistance(domain=Continuous())
D = SpectralDistances.distmat(distance, models, normalize=true)</code></pre><p>with this matrix, we can, for instance, run clustering:</p><pre><code class="language-julia">using Clustering
cr = hclust(Symmetric(sqrt.(D)))
assignments = cutree(cr,k=30) # k is desired number of clusters</code></pre><p>Another clustering approach is to use <a href="../interpolations/#SpectralDistances.kbarycenters-Tuple{Any,Any,Any}"><code>kbarycenters</code></a>, see example in the docstring.</p><h2 id="Detection-using-examples-1"><a class="docs-heading-anchor" href="#Detection-using-examples-1">Detection using examples</a><a class="docs-heading-anchor-permalink" href="#Detection-using-examples-1" title="Permalink"></a></h2><p>A measure of distance can be used for detection, by selecting a few positive examples and calculating the distance to the nearest neighbor within these examples from a new query point, a simple example:</p><pre><code class="language-julia">function scorefunction(query_model)
    distance = OptimalTransportRootDistance(domain=Continuous())
    distance_vector = distance.(Ref(query_model),positive_example_models)
    score = minimum(distance_vector)
end</code></pre><p>This can be made significantly more effective (but less accurate) using the <code>knn</code> approach from the <a href="#Nearest-Neighbor-classification-1">Nearest Neighbor classification</a>. If you want to detect a small number of patterns in a much longer signal, see the method using <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance,TimeVaryingAR,TimeVaryingAR}"><code>SlidingDistancesBase.distance_profile</code></a> below.</p><h2 id="Computing-a-spectrogram-distance-profile-1"><a class="docs-heading-anchor" href="#Computing-a-spectrogram-distance-profile-1">Computing a spectrogram distance profile</a><a class="docs-heading-anchor-permalink" href="#Computing-a-spectrogram-distance-profile-1" title="Permalink"></a></h2><p>In this example, we&#39;ll search through a long spectrogram <code>Y</code> for a short query <code>Q</code>. We will compute a <em>distance profile</em>, which is a vector with all distance between <code>Q</code> and each window into <code>Y</code> of the same length as <code>Q</code>. The distance profile should have minima roughly where <code>Y</code> has the same frequencies as the query, and the global minimum where the chirp has increasing frequency (you can zoon into the figure to verify).</p><p>To make computing distance profiles faster, <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance,TimeVaryingAR,TimeVaryingAR}"><code>SlidingDistancesBase.distance_profile</code></a> accepts a <code>stride</code>. We also set <code>β</code> relatively high to get a smooth and noise-free distance profile.</p><pre><code class="language-julia">using SpectralDistances, DSP, Plots
Q = spectrogram(
    sin.(LinRange(0.9, 1.1, 10000).^ 2 .* (1:10000)) .+ 0.1 * randn(10000),
    256,
    window = hanning,
)
Y = spectrogram(
    sin.(LinRange(0.7, 1.6, 300_000).^ 2 .* (1:300_000)) .+ 0.01 * randn(300_000),
    256,
    window = hanning,
)

d = ConvOptimalTransportDistance(β=0.05, dynamic_floor=-3.0)
D = distance_profile(d, Q, Y, tol=1e-6, stride=15)
plot(
    plot(Y, title = &quot;Data&quot;),
    plot(Q, title = &quot;Query spectrogram&quot;),
    plot(D, title = &quot;Distance Profile&quot;),
    legend = false,
    colorbar = false,
)</code></pre><object type="text/html" data="../dist_profile.html" style="width:100%;height:450px;"></object><h2 id="The-closed-form-solution-1"><a class="docs-heading-anchor" href="#The-closed-form-solution-1">The closed-form solution</a><a class="docs-heading-anchor-permalink" href="#The-closed-form-solution-1" title="Permalink"></a></h2><p>In this example we will simply visalize two spectra, the locations of their poles and the cumulative spectrum functions.</p><pre><code class="language-julia">using ControlSystems, SpectralDistances, Plots
plotly(grid=false)

G1   = tf(1,[1,0.12,1])*tf(1,[1,0.1,0.1])
G2   = tf(1,[1,0.12,2])*tf(1,[1,0.1,0.4])
a1   = denvec(G1)[]
a2   = denvec(G2)[]
n    = length(a1)

f1c  = w -&gt; abs2(1/sum(j-&gt;a1[j]*(im*w)^(n-j), 1:n))
f2c  = w -&gt; abs2(1/sum(j-&gt;a2[j]*(im*w)^(n-j), 1:n))
sol1 = SpectralDistances.c∫(f1c,0,3π)
sol2 = SpectralDistances.c∫(f2c,0,3π)

fig1 = plot((sol1.t .+ sol1.t[2]).*2π, sqrt.(sol1 ./ sol1[end]), fillrange=sqrt.(sol2(sol1.t) ./ sol2[end]), fill=(0.6,:purple), l=(2,:blue))
plot!((sol2.t .+ sol2.t[2]).*2π, sqrt.(sol2(sol2.t) ./ sol2[end]), l=(2,:orange), xscale=:log10, legend=false, grid=false, xlabel=&quot;Frequency&quot;, xlims=(1e-2,2pi))

fig2 = bodeplot([G1, G2], exp10.(LinRange(-1.5, 1, 200)), legend=false, grid=false, title=&quot;&quot;, linecolor=[:blue :orange], l=(2,), plotphase=false)

fig3 = pzmap([G1, G2], legend=false, grid=false, title=&quot;&quot;, markercolor=[:blue :orange], color=[:blue :orange], m=(2,:c), xlims=(-0.5,0.5))
vline!([0], l=(:black, :dash))
hline!([0], l=(:black, :dash))

plot(fig1, fig2, fig3, layout=(1,3))</code></pre><pre><code class="language-none">┌ Warning: Spectral integration failed, increasing precision
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/losses.jl:766
┌ Warning: Spectral integration failed, increasing precision
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/losses.jl:766</code></pre><object type="text/html" data="../cumulative.html" style="width:100%;height:450px;"></object></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../misc/">« Misc.</a><a class="docs-footer-nextpage" href="../taskview/">Task View »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 June 2020 05:51">Monday 22 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
