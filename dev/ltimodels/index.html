<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models and root manipulations · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li class="is-active"><a class="tocitem" href>Models and root manipulations</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Time-domain-1"><span>Time domain</span></a></li><li><a class="tocitem" href="#Computational-performance-improvements-1"><span>Computational performance improvements</span></a></li><li><a class="tocitem" href="#Further-reading-and-examples-1"><span>Further reading and examples</span></a></li><li><a class="tocitem" href="#Type-reference-1"><span>Type reference</span></a></li><li><a class="tocitem" href="#Function-reference-1"><span>Function reference</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Models and root manipulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models and root manipulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/ltimodels.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models-and-root-manipulations-1"><a class="docs-heading-anchor" href="#Models-and-root-manipulations-1">Models and root manipulations</a><a class="docs-heading-anchor-permalink" href="#Models-and-root-manipulations-1" title="Permalink"></a></h1><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Most distances available in this package operate on linear models estimated from a time-domain signal. This package supports two kind of LTI models, <a href="#SpectralDistances.AR"><code>AR</code></a> and <a href="#SpectralDistances.ARMA"><code>ARMA</code></a>. <a href="#SpectralDistances.AR"><code>AR</code></a> represents a model with only poles whereas <a href="#SpectralDistances.ARMA"><code>ARMA</code></a> has zeros as well. These types are subtypes of <code>ControlSystems.LTISystem</code>, so many of the functions from the <a href="https://github.com/JuliaControl/ControlSystems.jl">ControlSystems.jl</a> toolbox work on these models as well. When acting like a <code>ControlSystems.LTISystem</code>, the default is to use the continuous-time representation of the model. The discrete-time representation can be obtained by <code>tf(m, 1)</code> where <code>1</code> is the sample time. More on the time-domain representation below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package makes the assumption that the sample time is 1 everywhere. When an <code>AbstractModel</code> is constructed, one must thus take care to rescale the frequency axis accordingly if this does not hold. If the discrete-time representation is never used, this is of no concern.</p></div></div><p>To fit a model to data, one first has to specify a <a href="#SpectralDistances.FitMethod"><code>FitMethod</code></a>, the options are</p><pre><code class="language-none">IRLS
LS
PLR
TLS
TimeWindow</code></pre><p>For example, to estimate an <a href="#SpectralDistances.AR"><code>AR</code></a> model of order 6 using least-squares, we can do the following</p><pre><code class="language-julia-repl">julia&gt; data = randn(1000);

julia&gt; fitmethod = LS(na=6)
LS(6, 0.01)

julia&gt; model = fitmethod(data)
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists. Consider prefiltering the signal or decreasing the regularization factor.
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/ltimodels.jl:83
AR{coeff type: Float64, root type: Complex{Float64}}(
b: 24.1879920231178
Cont. poles: 6-element ContinuousRoots{Complex{Float64},Array{Complex{Float64},1}}:
  -0.543568696277846 - 2.235125945694924im
 -0.6109325622076213 - 0.9074245948536653im
 -1.0012533692830874 + 0.0im
 -0.6109325622076213 + 0.9074245948536653im
  -0.543568696277846 + 2.235125945694924im
 -0.9922236868551086 + 3.141592653589793im
Abs disc: [0.5806723072668087, 0.5428443967836869, 0.3674186412165771, 0.5428443967836869, 0.5806723072668087, 0.37075133882107425]
Cont. coeffs: 7-element Array{Float64,1}:
  1.0
  4.302479573109131
 13.412659026707326
 25.641561424234055
 29.578614490165485
 20.3377406098773
  6.290458646503813
Spectral energy: 1.0442449114635568

julia&gt; change_precision(Float32, model) # Can be useful to reduce the computational cost of some distances
AR{coeff type: Float32, root type: Complex{Float32}}(
b: 24.1879920231178
Cont. poles: 6-element ContinuousRoots{Complex{Float32},Array{Complex{Float32},1}}:
 -0.5435687f0 - 2.235126f0im
 -0.6109326f0 - 0.90742457f0im
 -1.0012534f0 + 0.0f0im
 -0.6109326f0 + 0.90742457f0im
 -0.5435687f0 + 2.235126f0im
 -0.9922237f0 + 3.1415927f0im
Abs disc: Float32[0.5806723, 0.5428444, 0.36741865, 0.5428444, 0.5806723, 0.37075135]
Cont. coeffs: 7-element Array{Float32,1}:
  1.0
  4.3024797
 13.412659
 25.641562
 29.578615
 20.33774
  6.2904587
Spectral energy: 1.0442449

julia&gt; pzmap(model)
┌ Warning: markershape x is unsupported with Plots.PlotlyBackend().  Choose from: [:none, :auto, :circle, :rect, :diamond, :utriangle, :dtriangle, :cross, :xcross, :pentagon, :hexagon, :octagon, :vline, :hline]
└ @ Plots ~/.julia/packages/Plots/E3MWZ/src/args.jl:1183
Plot{Plots.PlotlyBackend() n=1}</code></pre><object type="text/html" data="../pzmap_models.html" style="width:100%;height:450px;"></object><h2 id="Time-domain-1"><a class="docs-heading-anchor" href="#Time-domain-1">Time domain</a><a class="docs-heading-anchor-permalink" href="#Time-domain-1" title="Permalink"></a></h2><p>This package allows you to view a model through two different lenses: as a continuous-time model that models the <em>differential</em> properties of the signal, or as a discrete-time model that models the <em>difference</em> properties of the signal. Signals are inevetably sampled before the computer interacts with them, and are thus natively in the discrete domain. Theory, on the other hand, is slightly more intuitive in the continuous time domain. The two domains are related by the <em>conformal mapping</em> <span>$p_c = \log(p_d)$</span> where <span>$p$</span> denotes a pole of a transfer function and subscripts <span>$c,d$</span> denote the continuous and discrete domains respectively. When creating a distance, the default domain is <a href="#SpectralDistances.Continuous"><code>Continuous</code></a>. Some functions require you to be explicit regarding which domain you have in mind, such as when creating models from vectors or when asking for the roots/poles of a model.</p><p>Sometimes you may get a message saying &quot;Roots on the negative real axis, no continuous time representation exist.&quot; when estimating a model from a signal. This means that one of the poles in the discrete time model, which is what is being estimated from data, landed on the legative real axis. No continuous-time system can ever create such a discrete-time model through sampling, and the some features of this package will work slightly worse if such a model is used, notably the <a href="../distances/#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> and <a href="../interpolations/#SpectralDistances.embedding-Tuple{Type{Array{T,1} where T},Any,Vararg{Any,N} where N}"><code>embedding</code></a>. Optimal-transport based distances will not have a problem with this scenario.</p><p>To reduce the likelihood of this occurring, you may try to bandpass filter the signal before estimating the model, reduce the regularization factor if regularization was used, change the model order, or consider using the <a href="#SpectralDistances.TLS"><code>TLS</code></a> fit method.</p><p>The difference between the pole locations in continuous and discrete time is vizualized in the pole diagrams below</p><pre><code class="language-julia">pzmap(model, layout=2, sp=1, xlabel=&quot;Re&quot;, ylabel=&quot;Im&quot;, title=&quot;Continuous&quot;)
vline!([0], primary=false, l=(:black, :dash), sp=1)
pzmap!(tf(model,1),    sp=2, xlabel=&quot;Re&quot;, ylabel=&quot;Im&quot;, title=&quot;Discrete&quot;)</code></pre><pre><code class="language-none">┌ Warning: markershape x is unsupported with Plots.PlotlyBackend().  Choose from: [:none, :auto, :circle, :rect, :diamond, :utriangle, :dtriangle, :cross, :xcross, :pentagon, :hexagon, :octagon, :vline, :hline]
└ @ Plots ~/.julia/packages/Plots/E3MWZ/src/args.jl:1183
┌ Warning: markershape x is unsupported with Plots.PlotlyBackend().  Choose from: [:none, :auto, :circle, :rect, :diamond, :utriangle, :dtriangle, :cross, :xcross, :pentagon, :hexagon, :octagon, :vline, :hline]
└ @ Plots ~/.julia/packages/Plots/E3MWZ/src/args.jl:1183</code></pre><object type="text/html" data="../pzmap_models2.html" style="width:100%;height:450px;"></object><h2 id="Computational-performance-improvements-1"><a class="docs-heading-anchor" href="#Computational-performance-improvements-1">Computational performance improvements</a><a class="docs-heading-anchor-permalink" href="#Computational-performance-improvements-1" title="Permalink"></a></h2><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul><h2 id="Further-reading-and-examples-1"><a class="docs-heading-anchor" href="#Further-reading-and-examples-1">Further reading and examples</a><a class="docs-heading-anchor-permalink" href="#Further-reading-and-examples-1" title="Permalink"></a></h2><p>This <a href="https://nbviewer.jupyter.org/github/baggepinnen/julia_examples/blob/master/identification_robust.ipynb">notebook</a> illustrates how the estimation of models in the presence of strong impulsive noise can be improved.</p><h2 id="Type-reference-1"><a class="docs-heading-anchor" href="#Type-reference-1">Type reference</a><a class="docs-heading-anchor-permalink" href="#Type-reference-1" title="Permalink"></a></h2><ul><li><a href="#SpectralDistances.AR"><code>SpectralDistances.AR</code></a></li><li><a href="#SpectralDistances.ARMA"><code>SpectralDistances.ARMA</code></a></li><li><a href="#SpectralDistances.AbstractModel"><code>SpectralDistances.AbstractModel</code></a></li><li><a href="#SpectralDistances.Continuous"><code>SpectralDistances.Continuous</code></a></li><li><a href="#SpectralDistances.ContinuousRoots"><code>SpectralDistances.ContinuousRoots</code></a></li><li><a href="#SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}"><code>SpectralDistances.ContinuousRoots</code></a></li><li><a href="#SpectralDistances.Discrete"><code>SpectralDistances.Discrete</code></a></li><li><a href="#SpectralDistances.DiscreteRoots"><code>SpectralDistances.DiscreteRoots</code></a></li><li><a href="#SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}"><code>SpectralDistances.DiscreteRoots</code></a></li><li><a href="#SpectralDistances.FitMethod"><code>SpectralDistances.FitMethod</code></a></li><li><a href="#SpectralDistances.HungarianAssignement"><code>SpectralDistances.HungarianAssignement</code></a></li><li><a href="#SpectralDistances.IRLS"><code>SpectralDistances.IRLS</code></a></li><li><a href="#SpectralDistances.LS"><code>SpectralDistances.LS</code></a></li><li><a href="#SpectralDistances.PLR"><code>SpectralDistances.PLR</code></a></li><li><a href="#SpectralDistances.SortAssignement"><code>SpectralDistances.SortAssignement</code></a></li><li><a href="#SpectralDistances.TLS"><code>SpectralDistances.TLS</code></a></li><li><a href="#SpectralDistances.TimeDomain"><code>SpectralDistances.TimeDomain</code></a></li></ul><h2 id="Function-reference-1"><a class="docs-heading-anchor" href="#Function-reference-1">Function reference</a><a class="docs-heading-anchor-permalink" href="#Function-reference-1" title="Permalink"></a></h2><ul><li><a href="#ControlSystems.denvec-Tuple{Discrete,SpectralDistances.AbstractModel}"><code>ControlSystems.denvec</code></a></li><li><a href="#ControlSystems.tf-Tuple{AR}"><code>ControlSystems.tf</code></a></li><li><a href="#ControlSystems.tf-Tuple{AR,Any}"><code>ControlSystems.tf</code></a></li><li><a href="#PolynomialRoots.roots"><code>PolynomialRoots.roots</code></a></li><li><a href="#SpectralDistances.change_precision-Tuple{Any,ContinuousRoots}"><code>SpectralDistances.change_precision</code></a></li><li><a href="#SpectralDistances.checkroots-Tuple{DiscreteRoots}"><code>SpectralDistances.checkroots</code></a></li><li><a href="#SpectralDistances.coefficients-Tuple{Discrete,AR}"><code>SpectralDistances.coefficients</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{Discrete,ContinuousRoots}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.examplemodels"><code>SpectralDistances.examplemodels</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{LS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{TLS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{IRLS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{PLR,AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.hungariansort"><code>SpectralDistances.hungariansort</code></a></li><li><a href="#SpectralDistances.ls"><code>SpectralDistances.ls</code></a></li><li><a href="#SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.normalization_factor</code></a></li><li><a href="#SpectralDistances.normalize_energy-Tuple{Any}"><code>SpectralDistances.normalize_energy</code></a></li><li><a href="#SpectralDistances.plr-NTuple{4,Any}"><code>SpectralDistances.plr</code></a></li><li><a href="#SpectralDistances.polar-Tuple{Number}"><code>SpectralDistances.polar</code></a></li><li><a href="#SpectralDistances.reflect-Tuple{ContinuousRoots}"><code>SpectralDistances.reflect</code></a></li><li><a href="#SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,AbstractArray{CT,1}}} where CT"><code>SpectralDistances.residues</code></a></li><li><a href="#SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residues</code></a></li><li><a href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residueweight</code></a></li><li><a href="#SpectralDistances.roots2poly-Union{Tuple{AbstractArray{CT,1}}, Tuple{CT}} where CT"><code>SpectralDistances.roots2poly</code></a></li><li><a href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>SpectralDistances.simplex_residueweight</code></a></li><li><a href="#SpectralDistances.spectralenergy-Tuple{LTISystem}"><code>SpectralDistances.spectralenergy</code></a></li><li><a href="#SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeDomain,AbstractArray{T,1},Any}} where T"><code>SpectralDistances.spectralenergy</code></a></li><li><a href="#SpectralDistances.unitweight-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>SpectralDistances.unitweight</code></a></li></ul><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AR" href="#SpectralDistances.AR"><code>SpectralDistances.AR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AR &lt;: AbstractModel</code></pre><p>Represents an all-pole transfer function, i.e., and AR model</p><p><strong>Arguments:</strong></p><ul><li><code>a</code>: denvec</li><li><code>ac</code>: denvec cont. time</li><li><code>p</code>: discrete time poles</li><li><code>pc</code>: continuous time poles</li><li><code>b</code>: Numerator scalar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ARMA" href="#SpectralDistances.ARMA"><code>SpectralDistances.ARMA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ARMA{T} &lt;: AbstractModel</code></pre><p>Represents an ARMA model, i.e., transfer function</p><p><strong>Arguments:</strong></p><ul><li><code>b</code>: numvec</li><li><code>bc</code>: numvec cont. time</li><li><code>a</code>: denvec</li><li><code>ac</code>: denvec cont. time</li><li><code>z</code>: zeros</li><li><code>p</code>: poles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L85-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractModel" href="#SpectralDistances.AbstractModel"><code>SpectralDistances.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type AbstractModel &lt;: ControlSystems.LTISystem end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.FitMethod" href="#SpectralDistances.FitMethod"><code>SpectralDistances.FitMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type that represents a way to fit a model to data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.IRLS" href="#SpectralDistances.IRLS"><code>SpectralDistances.IRLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IRLS &lt;: FitMethod</code></pre><p>Iteratively reqeighted least squares. This fitmethod is currently not recommended, it does not appear to produce nice spectra. (feel free to try it out though).</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L385-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.LS" href="#SpectralDistances.LS"><code>SpectralDistances.LS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LS &lt;: FitMethod</code></pre><p>This fitmethod is a good default option.</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system). The number of peaks in the spectrum will be <code>na÷2</code>.</li><li><code>λ::Float64 = 0.01</code>: reg factor</li></ul><p><strong>Computational performance improvements</strong></p><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L266-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.PLR" href="#SpectralDistances.PLR"><code>SpectralDistances.PLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLR &lt;: FitMethod</code></pre><p>Pseudo linear regression. Estimates the noise components by performing an initial fit of higher order. Tihs fitmethod produces an <a href="#SpectralDistances.ARMA"><code>ARMA</code></a> model. Support for ARMA models is not as strong as for <a href="#SpectralDistances.AR"><code>AR</code></a> models.</p><p><strong>Arguments:</strong></p><ul><li><code>nc::Int</code>: order of numerator</li><li><code>na::Int</code>: order of denomenator</li><li><code>initial::T = TLS(na=80)</code>: fitmethod for the initial fit. Can be, e.g., <a href="#SpectralDistances.LS"><code>LS</code></a>, <a href="#SpectralDistances.TLS"><code>TLS</code></a> or any function that returns a coefficient vector</li><li><code>λ::Float64 = 0.0001</code>: reg factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L407-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.TLS" href="#SpectralDistances.TLS"><code>SpectralDistances.TLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TLS &lt;: FitMethod</code></pre><p>Total least squares. This fit method is good if the spectrum has sharp peaks, in particular if the number of peaks is known in advance.</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system). The number of peaks in the spectrum will be <code>na÷2</code>.</li><li><code>λ::Float64 = 0</code>: reg factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L346-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolynomialRoots.roots" href="#PolynomialRoots.roots"><code>PolynomialRoots.roots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">roots(m::AbstractModel)</code></pre><p>Returns the roots of a model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.checkroots-Tuple{DiscreteRoots}" href="#SpectralDistances.checkroots-Tuple{DiscreteRoots}"><code>SpectralDistances.checkroots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>checkroots(r::DiscreteRoots)</code> prints a warning if there are roots on the negative real axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.coefficients-Tuple{Discrete,AR}" href="#SpectralDistances.coefficients-Tuple{Discrete,AR}"><code>SpectralDistances.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficients(::Domain, m::AbstractModel)</code></pre><p>Return all fitted coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.examplemodels" href="#SpectralDistances.examplemodels"><code>SpectralDistances.examplemodels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">examplemodels(n = 10)</code></pre><p>Return <code>n</code> random models with 6 complex poles each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L820-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{IRLS,AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{IRLS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitmodel(fm::IRLS, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L398-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{LS,AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{LS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitmodel(fm::LS, X::AbstractArray)</code></pre><p><strong>Computational performance improvements</strong></p><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L287-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{PLR,AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{PLR,AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitmodel(fm::PLR, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L425-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{TLS,AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{TLS,AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitmodel(fm::TLS, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L361-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ls" href="#SpectralDistances.ls"><code>SpectralDistances.ls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ls(A, y, λ=0)</code></pre><p>Regularized Least-squares</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.normalization_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_energy(r)</code></pre><p>Returns the factor that, when used to multiply the poles, results in a system with unit spectral energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L784-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.normalize_energy-Tuple{Any}" href="#SpectralDistances.normalize_energy-Tuple{Any}"><code>SpectralDistances.normalize_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_energy(r)</code></pre><p>Returns poles scaled to achieve unit spectral energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L795-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.plr-NTuple{4,Any}" href="#SpectralDistances.plr-NTuple{4,Any}"><code>SpectralDistances.plr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plr(y, na, nc, initial; λ=0.01)</code></pre><p>Performs pseudo-linear regression to estimate an ARMA model.</p><p><strong>Arguments:</strong></p><ul><li><code>y</code>: signal</li><li><code>na</code>: denomenator order</li><li><code>nc</code>: numerator order</li><li><code>initial</code>: fitmethod for the initial fit. Can be, e.g., <a href="#SpectralDistances.LS"><code>LS</code></a>, <a href="#SpectralDistances.TLS"><code>TLS</code></a> or any function that returns a coefficient vector</li><li><code>λ</code>: reg</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L433-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">residues(r::AbstractRoots)</code></pre><p>Returns a vector of residues for the system represented by roots <code>r</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L661-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,AbstractArray{CT,1}}} where CT" href="#SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,AbstractArray{CT,1}}} where CT"><code>SpectralDistances.residues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">residues(a::AbstractVector, b, r=roots(reverse(a)))</code></pre><p>Returns a vector of residues for the system represented by denominator polynomial <code>a</code></p><p>Ref: slide 21 https://stanford.edu/~boyd/ee102/rational.pdf Tihs methid is numerically sensitive. Note that if two poles are on top of each other, the residue is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L630-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.roots2poly-Union{Tuple{AbstractArray{CT,1}}, Tuple{CT}} where CT" href="#SpectralDistances.roots2poly-Union{Tuple{AbstractArray{CT,1}}, Tuple{CT}} where CT"><code>SpectralDistances.roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">roots2poly(roots)</code></pre><p>Accepts a vector of complex roots and returns the polynomial with those roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L564-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.spectralenergy-Tuple{LTISystem}" href="#SpectralDistances.spectralenergy-Tuple{LTISystem}"><code>SpectralDistances.spectralenergy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectralenergy(G::LTISystem)</code></pre><p>Calculates the energy in the spectrum associated with <code>G</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L712-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeDomain,AbstractArray{T,1},Any}} where T" href="#SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeDomain,AbstractArray{T,1},Any}} where T"><code>SpectralDistances.spectralenergy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectralenergy(d::TimeDomain, a::AbstractVector, b)</code></pre><p>Calculates the energy in the spectrum associated with transfer function <code>b/a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L733-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.Continuous" href="#SpectralDistances.Continuous"><code>SpectralDistances.Continuous</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Continuous time domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ContinuousRoots" href="#SpectralDistances.ContinuousRoots"><code>SpectralDistances.ContinuousRoots</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousRoots{T, V &lt;: AbstractVector{T}} &lt;: AbstractRoots{T}</code></pre><p>Represents roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}" href="#SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}"><code>SpectralDistances.ContinuousRoots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ContinuousRoots(r::DiscreteRoots) = begin</code></pre><p>Represents roots of a polynomial in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.Discrete" href="#SpectralDistances.Discrete"><code>SpectralDistances.Discrete</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete (sampled) time domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteRoots" href="#SpectralDistances.DiscreteRoots"><code>SpectralDistances.DiscreteRoots</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteRoots{T, V &lt;: AbstractVector{T}} &lt;: AbstractRoots{T}</code></pre><p>Represent roots in discrete time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}" href="#SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}"><code>SpectralDistances.DiscreteRoots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteRoots(r::ContinuousRoots) = begin</code></pre><p>Represents roots of a polynomial in discrete time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.HungarianAssignement" href="#SpectralDistances.HungarianAssignement"><code>SpectralDistances.HungarianAssignement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HungarianAssignement &lt;: AbstractAssignmentMethod</code></pre><p>Sort roots using Hungarian method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SortAssignement" href="#SpectralDistances.SortAssignement"><code>SpectralDistances.SortAssignement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SortAssignement{F} &lt;: AbstractAssignmentMethod</code></pre><p>Contains a single Function field that determines what to sort roots by.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.TimeDomain" href="#SpectralDistances.TimeDomain"><code>SpectralDistances.TimeDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type that represents a time-domain, either <code>Discrete</code> or <code>Continuous</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.change_precision-Tuple{Any,ContinuousRoots}" href="#SpectralDistances.change_precision-Tuple{Any,ContinuousRoots}"><code>SpectralDistances.change_precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_precision(F, m::AbstractModel)</code></pre><p>Changes the precision of all fields in <code>m</code> to <code>F</code>, e.g., <code>F=Float64</code>. This can be useful since the default precision for many operations in this package is <code>Double64</code>. This ensures that roots are calculated with high accuracy, but the high precision might not be required to evaluate distances etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{Discrete,ContinuousRoots}" href="#SpectralDistances.domain_transform-Tuple{Discrete,ContinuousRoots}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain_transform(d::Domain, e::AbstractRoots)</code></pre><p>Change the domain of the roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.hungariansort" href="#SpectralDistances.hungariansort"><code>SpectralDistances.hungariansort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hungariansort(p1, p2)</code></pre><p>takes two vectors of numbers and sorts and returns <code>p2</code> such that it is in the order of the best Hungarian assignement between <code>p1</code> and <code>p2</code>. Uses <code>abs</code> for comparisons, works on complex numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.polar-Tuple{Number}" href="#SpectralDistances.polar-Tuple{Number}"><code>SpectralDistances.polar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polar(e::Number)</code></pre><p>magnitude and angle of a complex number</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.reflect-Tuple{ContinuousRoots}" href="#SpectralDistances.reflect-Tuple{ContinuousRoots}"><code>SpectralDistances.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reflect(r::AbstractRoots)</code></pre><p>Reflects unstable roots to a corresponding stable position (in unit circle for disc. in LHP for cont.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residueweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">residueweight(e::AbstractRoots)</code></pre><p>Returns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole. See also <a href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>simplex_residueweight</code></a> for a normalized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.simplex_residueweight-Tuple{Any}" href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>SpectralDistances.simplex_residueweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simplex_residueweight(x)</code></pre><p>Returns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole, normalized to sum to 1. See <a href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a> for a non-normalized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.unitweight-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T" href="#SpectralDistances.unitweight-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>SpectralDistances.unitweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitweight(e)</code></pre><p>A weighting function that returns a vector of uniform weights that sum to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/eigenvalue_manipulations.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tf-Tuple{AR,Any}" href="#ControlSystems.tf-Tuple{AR,Any}"><code>ControlSystems.tf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ControlSystems.tf(m::AR, ts)</code></pre><p>Convert model to a transfer function compatible with ControlSystems.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tf-Tuple{AR}" href="#ControlSystems.tf-Tuple{AR}"><code>ControlSystems.tf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ControlSystems.tf(m::AR)</code></pre><p>Convert model to a transfer function compatible with ControlSystems.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.denvec-Tuple{Discrete,SpectralDistances.AbstractModel}" href="#ControlSystems.denvec-Tuple{Discrete,SpectralDistances.AbstractModel}"><code>ControlSystems.denvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ControlSystems.denvec(::TimeDomain, m::AbstractModel)</code></pre><p>Get the denominator polynomial vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/58470a4c97a2ac871a26010b72efb835ae5d2246/src/ltimodels.jl#L210-L214">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SpectralDistances</a><a class="docs-footer-nextpage" href="../distances/">Distances »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 June 2020 15:23">Tuesday 23 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
