<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models and root manipulations · SpectralDistances</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralDistances</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li class="is-active"><a class="tocitem" href>Models and root manipulations</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Time-domain"><span>Time domain</span></a></li><li><a class="tocitem" href="#Computational-performance-improvements"><span>Computational performance improvements</span></a></li><li><a class="tocitem" href="#Further-reading-and-examples"><span>Further reading and examples</span></a></li><li><a class="tocitem" href="#Type-reference"><span>Type reference</span></a></li><li><a class="tocitem" href="#Function-reference"><span>Function reference</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Models and root manipulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models and root manipulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/ltimodels.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models-and-root-manipulations"><a class="docs-heading-anchor" href="#Models-and-root-manipulations">Models and root manipulations</a><a id="Models-and-root-manipulations-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-root-manipulations" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Most distances available in this package operate on linear models estimated from a time-domain signal. This package supports two kind of LTI models, <a href="#SpectralDistances.AR"><code>AR</code></a> and <a href="#SpectralDistances.ARMA"><code>ARMA</code></a>. <a href="#SpectralDistances.AR"><code>AR</code></a> represents a model with only poles whereas <a href="#SpectralDistances.ARMA"><code>ARMA</code></a> has zeros as well. These types are subtypes of <code>ControlSystemsBase.LTISystem</code>, so many of the functions from the <a href="https://github.com/JuliaControl/ControlSystemsBase.jl">ControlSystemsBase.jl</a> toolbox work on these models as well. When acting like a <code>ControlSystemsBase.LTISystem</code>, the default is to use the continuous-time representation of the model. The discrete-time representation can be obtained by <code>tf(m, 1)</code> where <code>1</code> is the sample time. More on the time-domain representation below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package makes the assumption that the sample time is 1 everywhere. When an <code>AbstractModel</code> is constructed, one must thus take care to rescale the frequency axis accordingly if this does not hold. If the discrete-time representation is never used, this is of no concern.</p></div></div><p>To fit a model to data, one first has to specify a <a href="#SpectralDistances.FitMethod"><code>FitMethod</code></a>, the options are</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IRLS
LS
PLR
TLS
TimeWindow</code></pre><p>For example, to estimate an <a href="#SpectralDistances.AR"><code>AR</code></a> model of order 6 using least-squares, we can do the following</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = randn(1000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fitmethod = LS(na=6)</code><code class="nohighlight hljs ansi" style="display:block;">LS(6, 0.01)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; model = fitmethod(data)</code><code class="nohighlight hljs ansi" style="display:block;">AR{coeff type: Float64, root type: ComplexF64}(
b: 60.12888697335969
Cont. poles: 6-element ContinuousRoots{ComplexF64, Vector{ComplexF64}}:
 -0.6372958001271409 - 2.5982848231027207im
 -0.6225043102185982 - 1.6516895568127195im
 -0.4962996701037562 - 0.5711257039907516im
 -0.4962996701037562 + 0.5711257039907516im
 -0.6225043102185982 + 1.6516895568127195im
 -0.6372958001271409 + 2.5982848231027207im
Abs disc: [0.5287202578529995, 0.5365989433133037, 0.6087791808150407, 0.6087791808150407, 0.5365989433133037, 0.5287202578529995]
Cont. coeffs: 7-element Vector{Float64}:
  1.0
  3.51219956089899
 14.933148945953075
 26.096311678801882
 41.87522960192869
 29.508838211776553
 12.766128041617707
Spectral energy: 0.9555752279189063</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; change_precision(Float32, model) # Can be useful to reduce the computational cost of some distances</code><code class="nohighlight hljs ansi" style="display:block;">AR{coeff type: Float32, root type: ComplexF32}(
b: 60.12888697335969
Cont. poles: 6-element ContinuousRoots{ComplexF32, Vector{ComplexF32}}:
  -0.6372958f0 - 2.5982847f0im
  -0.6225043f0 - 1.6516895f0im
 -0.49629968f0 - 0.5711257f0im
 -0.49629968f0 + 0.5711257f0im
  -0.6225043f0 + 1.6516895f0im
  -0.6372958f0 + 2.5982847f0im
Abs disc: Float32[0.52872026, 0.5365989, 0.6087792, 0.6087792, 0.5365989, 0.52872026]
Cont. coeffs: 7-element Vector{Float32}:
  1.0
  3.5121996
 14.933149
 26.096312
 41.87523
 29.508839
 12.766128
Spectral energy: 0.9555753</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pzmap(model)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.PlotlyBackend() n=1}</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><object type="text/html" data="../pzmap_models.html" style="width:100%;height:450px;"></object><h2 id="Time-domain"><a class="docs-heading-anchor" href="#Time-domain">Time domain</a><a id="Time-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Time-domain" title="Permalink"></a></h2><p>This package allows you to view a model through two different lenses: as a continuous-time model that models the <em>differential</em> properties of the signal, or as a discrete-time model that models the <em>difference</em> properties of the signal. Signals are inevetably sampled before the computer interacts with them, and are thus natively in the discrete domain. Theory, on the other hand, is slightly more intuitive in the continuous time domain. The two domains are related by the <em>conformal mapping</em> <span>$p_c = \log(p_d)$</span> where <span>$p$</span> denotes a pole of a transfer function and subscripts <span>$c,d$</span> denote the continuous and discrete domains respectively. When creating a distance, the default domain is <a href="@ref"><code>Continuous</code></a>. Some functions require you to be explicit regarding which domain you have in mind, such as when creating models from vectors or when asking for the roots/poles of a model.</p><p>Sometimes you may get a message saying &quot;Roots on the negative real axis, no continuous time representation exist.&quot; when estimating a model from a signal. This means that one of the poles in the discrete time model, which is what is being estimated from data, landed on the legative real axis. No continuous-time system can ever create such a discrete-time model through sampling, and the some features of this package will work slightly worse if such a model is used, notably the <a href="../distances/#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> and <a href="../interpolations/#SpectralDistances.embedding-Tuple{Type{Vector}, Any, Vararg{Any}}"><code>embedding</code></a>. Optimal-transport based distances will not have a problem with this scenario.</p><p>To reduce the likelihood of this occurring, you may try to bandpass filter the signal before estimating the model, reduce the regularization factor if regularization was used, change the model order, or consider using the <a href="#SpectralDistances.TLS"><code>TLS</code></a> fit method.</p><p>The difference between the pole locations in continuous and discrete time is vizualized in the pole diagrams below</p><pre><code class="language-julia hljs">pzmap(model, layout=2, sp=1, xlabel=&quot;Re&quot;, ylabel=&quot;Im&quot;, title=&quot;Continuous&quot;)
vline!([0], primary=false, l=(:black, :dash), sp=1)
pzmap!(tf(model,1),    sp=2, xlabel=&quot;Re&quot;, ylabel=&quot;Im&quot;, title=&quot;Discrete&quot;)</code></pre><object type="text/html" data="../pzmap_models2.html" style="width:100%;height:450px;"></object><h2 id="Computational-performance-improvements"><a class="docs-heading-anchor" href="#Computational-performance-improvements">Computational performance improvements</a><a id="Computational-performance-improvements-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-performance-improvements" title="Permalink"></a></h2><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul><h2 id="Further-reading-and-examples"><a class="docs-heading-anchor" href="#Further-reading-and-examples">Further reading and examples</a><a id="Further-reading-and-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading-and-examples" title="Permalink"></a></h2><p>This <a href="https://nbviewer.jupyter.org/github/baggepinnen/julia_examples/blob/master/identification_robust.ipynb">notebook</a> illustrates how the estimation of models in the presence of strong impulsive noise can be improved.</p><h2 id="Type-reference"><a class="docs-heading-anchor" href="#Type-reference">Type reference</a><a id="Type-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Type-reference" title="Permalink"></a></h2><ul><li><a href="#SpectralDistances.AR"><code>SpectralDistances.AR</code></a></li><li><a href="#SpectralDistances.ARMA"><code>SpectralDistances.ARMA</code></a></li><li><a href="#SpectralDistances.AbstractModel"><code>SpectralDistances.AbstractModel</code></a></li><li><a href="#SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}"><code>SpectralDistances.ContinuousRoots</code></a></li><li><a href="#SpectralDistances.ContinuousRoots"><code>SpectralDistances.ContinuousRoots</code></a></li><li><a href="#SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}"><code>SpectralDistances.DiscreteRoots</code></a></li><li><a href="#SpectralDistances.DiscreteRoots"><code>SpectralDistances.DiscreteRoots</code></a></li><li><a href="#SpectralDistances.FitMethod"><code>SpectralDistances.FitMethod</code></a></li><li><a href="#SpectralDistances.HungarianAssignement"><code>SpectralDistances.HungarianAssignement</code></a></li><li><a href="#SpectralDistances.IRLS"><code>SpectralDistances.IRLS</code></a></li><li><a href="#SpectralDistances.LS"><code>SpectralDistances.LS</code></a></li><li><a href="#SpectralDistances.PLR"><code>SpectralDistances.PLR</code></a></li><li><a href="#SpectralDistances.SortAssignement"><code>SpectralDistances.SortAssignement</code></a></li><li><a href="#SpectralDistances.TLS"><code>SpectralDistances.TLS</code></a></li></ul><h2 id="Function-reference"><a class="docs-heading-anchor" href="#Function-reference">Function reference</a><a id="Function-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-reference" title="Permalink"></a></h2><ul><li><a href="#ControlSystemsBase.denvec-Tuple{Discrete, SpectralDistances.AbstractModel}"><code>ControlSystemsBase.denvec</code></a></li><li><a href="#ControlSystemsBase.tf-Tuple{AR, Any}"><code>ControlSystemsBase.tf</code></a></li><li><a href="#ControlSystemsBase.tf-Tuple{AR}"><code>ControlSystemsBase.tf</code></a></li><li><a href="#PolynomialRoots.roots"><code>PolynomialRoots.roots</code></a></li><li><a href="#SpectralDistances.change_precision-Tuple{Any, ContinuousRoots}"><code>SpectralDistances.change_precision</code></a></li><li><a href="#SpectralDistances.checkroots-Tuple{DiscreteRoots}"><code>SpectralDistances.checkroots</code></a></li><li><a href="#SpectralDistances.coefficients-Tuple{Discrete, AR}"><code>SpectralDistances.coefficients</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{Discrete, ContinuousRoots}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.examplemodels"><code>SpectralDistances.examplemodels</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{TLS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{IRLS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{LS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.fitmodel-Tuple{PLR, AbstractArray}"><code>SpectralDistances.fitmodel</code></a></li><li><a href="#SpectralDistances.hungariansort"><code>SpectralDistances.hungariansort</code></a></li><li><a href="#SpectralDistances.ls"><code>SpectralDistances.ls</code></a></li><li><a href="#SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.normalization_factor</code></a></li><li><a href="#SpectralDistances.normalize_energy-Tuple{Any}"><code>SpectralDistances.normalize_energy</code></a></li><li><a href="#SpectralDistances.plr-NTuple{4, Any}"><code>SpectralDistances.plr</code></a></li><li><a href="#SpectralDistances.polar-Tuple{Number}"><code>SpectralDistances.polar</code></a></li><li><a href="#SpectralDistances.reflect-Tuple{ContinuousRoots}"><code>SpectralDistances.reflect</code></a></li><li><a href="#SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residues</code></a></li><li><a href="#SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractVector, Any}, Tuple{AbstractVector, Any, AbstractVector{CT}}} where CT"><code>SpectralDistances.residues</code></a></li><li><a href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residueweight</code></a></li><li><a href="#SpectralDistances.roots2poly-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT"><code>SpectralDistances.roots2poly</code></a></li><li><a href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>SpectralDistances.simplex_residueweight</code></a></li><li><a href="#SpectralDistances.spectralenergy-Tuple{LTISystem}"><code>SpectralDistances.spectralenergy</code></a></li><li><a href="#SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeEvolution, AbstractVector{T}, Any}} where T"><code>SpectralDistances.spectralenergy</code></a></li><li><a href="#SpectralDistances.unitweight-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>SpectralDistances.unitweight</code></a></li></ul><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AR" href="#SpectralDistances.AR"><code>SpectralDistances.AR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AR &lt;: AbstractModel</code></pre><p>Represents an all-pole transfer function, i.e., and AR model</p><p><strong>Arguments:</strong></p><ul><li><code>a</code>: denvec</li><li><code>ac</code>: denvec cont. time</li><li><code>p</code>: discrete time poles</li><li><code>pc</code>: continuous time poles</li><li><code>b</code>: Numerator scalar</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ARMA" href="#SpectralDistances.ARMA"><code>SpectralDistances.ARMA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ARMA{T} &lt;: AbstractModel</code></pre><p>Represents an ARMA model, i.e., transfer function</p><p><strong>Arguments:</strong></p><ul><li><code>b</code>: numvec</li><li><code>bc</code>: numvec cont. time</li><li><code>a</code>: denvec</li><li><code>ac</code>: denvec cont. time</li><li><code>z</code>: zeros</li><li><code>p</code>: poles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L85-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractModel" href="#SpectralDistances.AbstractModel"><code>SpectralDistances.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>abstract type AbstractModel &lt;: ControlSystemsBase.LTISystem end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.FitMethod" href="#SpectralDistances.FitMethod"><code>SpectralDistances.FitMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type that represents a way to fit a model to data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.IRLS" href="#SpectralDistances.IRLS"><code>SpectralDistances.IRLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IRLS &lt;: FitMethod</code></pre><p>Iteratively reqeighted least squares. This fitmethod is currently not recommended, it does not appear to produce nice spectra. (feel free to try it out though).</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L391-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.LS" href="#SpectralDistances.LS"><code>SpectralDistances.LS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LS &lt;: FitMethod</code></pre><p>This fitmethod is a good default option.</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system). The number of peaks in the spectrum will be <code>na÷2</code>.</li><li><code>λ::Float64 = 0.01</code>: reg factor</li></ul><p><strong>Computational performance improvements</strong></p><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L272-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.PLR" href="#SpectralDistances.PLR"><code>SpectralDistances.PLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PLR &lt;: FitMethod</code></pre><p>Pseudo linear regression. Estimates the noise components by performing an initial fit of higher order. Tihs fitmethod produces an <a href="#SpectralDistances.ARMA"><code>ARMA</code></a> model. Support for ARMA models is not as strong as for <a href="#SpectralDistances.AR"><code>AR</code></a> models.</p><p><strong>Arguments:</strong></p><ul><li><code>nc::Int</code>: order of numerator</li><li><code>na::Int</code>: order of denomenator</li><li><code>initial::T = TLS(na=80)</code>: fitmethod for the initial fit. Can be, e.g., <a href="#SpectralDistances.LS"><code>LS</code></a>, <a href="#SpectralDistances.TLS"><code>TLS</code></a> or any function that returns a coefficient vector</li><li><code>λ::Float64 = 0.0001</code>: reg factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L413-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.TLS" href="#SpectralDistances.TLS"><code>SpectralDistances.TLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TLS &lt;: FitMethod</code></pre><p>Total least squares. This fit method is good if the spectrum has sharp peaks, in particular if the number of peaks is known in advance.</p><p><strong>Arguments:</strong></p><ul><li><code>na::Int</code>: number of roots (order of the system). The number of peaks in the spectrum will be <code>na÷2</code>.</li><li><code>λ::Float64 = 0</code>: reg factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L352-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolynomialRoots.roots" href="#PolynomialRoots.roots"><code>PolynomialRoots.roots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roots(m::AbstractModel)</code></pre><p>Returns the roots of a model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.checkroots-Tuple{DiscreteRoots}" href="#SpectralDistances.checkroots-Tuple{DiscreteRoots}"><code>SpectralDistances.checkroots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>checkroots(r::DiscreteRoots)</code> prints a warning if there are roots on the negative real axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.coefficients-Tuple{Discrete, AR}" href="#SpectralDistances.coefficients-Tuple{Discrete, AR}"><code>SpectralDistances.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients(::Domain, m::AbstractModel)</code></pre><p>Return all fitted coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.examplemodels" href="#SpectralDistances.examplemodels"><code>SpectralDistances.examplemodels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">examplemodels(n = 10)</code></pre><p>Return <code>n</code> random models with 6 complex poles each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L827-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{IRLS, AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{IRLS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitmodel(fm::IRLS, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L404-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{LS, AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{LS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitmodel(fm::LS, X::AbstractArray)</code></pre><p><strong>Computational performance improvements</strong></p><p>Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by</p><ul><li>Using <code>Flaot32</code> instead of <code>Float64</code></li><li>Use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> instead of the default OpenBLAS (can yield about 2x performance improvement).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L293-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{PLR, AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{PLR, AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitmodel(fm::PLR, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L431-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.fitmodel-Tuple{TLS, AbstractArray}" href="#SpectralDistances.fitmodel-Tuple{TLS, AbstractArray}"><code>SpectralDistances.fitmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitmodel(fm::TLS, X::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L367-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ls" href="#SpectralDistances.ls"><code>SpectralDistances.ls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ls(A, y, λ=0)</code></pre><p>Regularized Least-squares</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.normalization_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_energy(r)</code></pre><p>Returns the factor that, when used to multiply the poles, results in a system with unit spectral energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L791-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.normalize_energy-Tuple{Any}" href="#SpectralDistances.normalize_energy-Tuple{Any}"><code>SpectralDistances.normalize_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_energy(r)</code></pre><p>Returns poles scaled to achieve unit spectral energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L802-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.plr-NTuple{4, Any}" href="#SpectralDistances.plr-NTuple{4, Any}"><code>SpectralDistances.plr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plr(y, na, nc, initial; λ=0.01)</code></pre><p>Performs pseudo-linear regression to estimate an ARMA model.</p><p><strong>Arguments:</strong></p><ul><li><code>y</code>: signal</li><li><code>na</code>: denomenator order</li><li><code>nc</code>: numerator order</li><li><code>initial</code>: fitmethod for the initial fit. Can be, e.g., <a href="#SpectralDistances.LS"><code>LS</code></a>, <a href="#SpectralDistances.TLS"><code>TLS</code></a> or any function that returns a coefficient vector</li><li><code>λ</code>: reg</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L439-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residues(r::AbstractRoots)</code></pre><p>Returns a vector of residues for the system represented by roots <code>r</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L667-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractVector, Any}, Tuple{AbstractVector, Any, AbstractVector{CT}}} where CT" href="#SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractVector, Any}, Tuple{AbstractVector, Any, AbstractVector{CT}}} where CT"><code>SpectralDistances.residues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residues(a::AbstractVector, b, r=roots(reverse(a)))</code></pre><p>Returns a vector of residues for the system represented by denominator polynomial <code>a</code></p><p>Ref: slide 21 https://stanford.edu/~boyd/ee102/rational.pdf Tihs methid is numerically sensitive. Note that if two poles are on top of each other, the residue is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L636-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.roots2poly-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT" href="#SpectralDistances.roots2poly-Union{Tuple{AbstractVector{CT}}, Tuple{CT}} where CT"><code>SpectralDistances.roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots2poly(roots)</code></pre><p>Accepts a vector of complex roots and returns the polynomial with those roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L570-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.spectralenergy-Tuple{LTISystem}" href="#SpectralDistances.spectralenergy-Tuple{LTISystem}"><code>SpectralDistances.spectralenergy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spectralenergy(G::LTISystem)</code></pre><p>Calculates the energy in the spectrum associated with <code>G</code> Ref: Robust and optimal control, Kemin Zhou, John C. Doyle, Keith Glover Lemma 4.6</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L718-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeEvolution, AbstractVector{T}, Any}} where T" href="#SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeEvolution, AbstractVector{T}, Any}} where T"><code>SpectralDistances.spectralenergy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spectralenergy(d::TimeEvolution, a::AbstractVector, b)</code></pre><p>Calculates the energy in the spectrum associated with transfer function <code>b/a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L740-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ContinuousRoots" href="#SpectralDistances.ContinuousRoots"><code>SpectralDistances.ContinuousRoots</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousRoots{T, V &lt;: AbstractVector{T}} &lt;: AbstractRoots{T}</code></pre><p>Represents roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}" href="#SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}"><code>SpectralDistances.ContinuousRoots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContinuousRoots(r::DiscreteRoots) = begin</code></pre><p>Represents roots of a polynomial in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteRoots" href="#SpectralDistances.DiscreteRoots"><code>SpectralDistances.DiscreteRoots</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscreteRoots{T, V &lt;: AbstractVector{T}} &lt;: AbstractRoots{T}</code></pre><p>Represent roots in discrete time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}" href="#SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}"><code>SpectralDistances.DiscreteRoots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteRoots(r::ContinuousRoots) = begin</code></pre><p>Represents roots of a polynomial in discrete time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.HungarianAssignement" href="#SpectralDistances.HungarianAssignement"><code>SpectralDistances.HungarianAssignement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HungarianAssignement &lt;: AbstractAssignmentMethod</code></pre><p>Sort roots using Hungarian method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SortAssignement" href="#SpectralDistances.SortAssignement"><code>SpectralDistances.SortAssignement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SortAssignement{F} &lt;: AbstractAssignmentMethod</code></pre><p>Contains a single Function field that determines what to sort roots by.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.change_precision-Tuple{Any, ContinuousRoots}" href="#SpectralDistances.change_precision-Tuple{Any, ContinuousRoots}"><code>SpectralDistances.change_precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_precision(F, m::AbstractModel)</code></pre><p>Changes the precision of all fields in <code>m</code> to <code>F</code>, e.g., <code>F=Float64</code>. This can be useful since the default precision for many operations in this package is <code>Double64</code>. This ensures that roots are calculated with high accuracy, but the high precision might not be required to evaluate distances etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{Discrete, ContinuousRoots}" href="#SpectralDistances.domain_transform-Tuple{Discrete, ContinuousRoots}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domain_transform(d::Domain, e::AbstractRoots)</code></pre><p>Change the domain of the roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.hungariansort" href="#SpectralDistances.hungariansort"><code>SpectralDistances.hungariansort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hungariansort(p1, p2)</code></pre><p>takes two vectors of numbers and sorts and returns <code>p2</code> such that it is in the order of the best Hungarian assignement between <code>p1</code> and <code>p2</code>. Uses <code>abs</code> for comparisons, works on complex numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.polar-Tuple{Number}" href="#SpectralDistances.polar-Tuple{Number}"><code>SpectralDistances.polar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polar(e::Number)</code></pre><p>magnitude and angle of a complex number</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.reflect-Tuple{ContinuousRoots}" href="#SpectralDistances.reflect-Tuple{ContinuousRoots}"><code>SpectralDistances.reflect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reflect(r::AbstractRoots)</code></pre><p>Reflects unstable roots to a corresponding stable position (in unit circle for disc. in LHP for cont.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}" href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>SpectralDistances.residueweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residueweight(e::AbstractRoots)</code></pre><p>Returns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole. See also <a href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>simplex_residueweight</code></a> for a normalized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.simplex_residueweight-Tuple{Any}" href="#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>SpectralDistances.simplex_residueweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplex_residueweight(x)</code></pre><p>Returns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole, normalized to sum to 1. See <a href="#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a> for a non-normalized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.unitweight-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T" href="#SpectralDistances.unitweight-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"><code>SpectralDistances.unitweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitweight(e)</code></pre><p>A weighting function that returns a vector of uniform weights that sum to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/eigenvalue_manipulations.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.tf-Tuple{AR, Any}" href="#ControlSystemsBase.tf-Tuple{AR, Any}"><code>ControlSystemsBase.tf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlSystemsBase.tf(m::AR, ts)</code></pre><p>Convert model to a transfer function compatible with ControlSystemsBase.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.tf-Tuple{AR}" href="#ControlSystemsBase.tf-Tuple{AR}"><code>ControlSystemsBase.tf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlSystemsBase.tf(m::AR)</code></pre><p>Convert model to a transfer function compatible with ControlSystemsBase.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.denvec-Tuple{Discrete, SpectralDistances.AbstractModel}" href="#ControlSystemsBase.denvec-Tuple{Discrete, SpectralDistances.AbstractModel}"><code>ControlSystemsBase.denvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlSystemsBase.denvec(::TimeEvolution, m::AbstractModel)</code></pre><p>Get the denominator polynomial vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/523c1c70e3a00d11058eebef10bddb112c330661/src/ltimodels.jl#L215-L219">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SpectralDistances</a><a class="docs-footer-nextpage" href="../distances/">Distances »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 4 July 2025 06:58">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
