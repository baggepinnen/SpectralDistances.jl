var documenterSearchIndex = {"docs":
[{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"using SpectralDistances, Plots\nplotly()","category":"page"},{"location":"time/#Time-Frequency-distances-1","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"For non-stationary signals, it is important to consider how the spectrum changes with time. This package has some, so far, basic support for time-frequency representations of non-stationary signals.","category":"page"},{"location":"time/#Overview-1","page":"Time-Frequency distances","title":"Overview","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"We define a custom fit method for fitting time varying spectra, TimeWindow. It takes as arguments an inner fitmethod, the number of points that form a time window, and the number of points that overlap between two consecutive time windows:","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"fitmethod = TimeWindow(LS(na=2), 1000, 500)\ny = sin.(0:0.1:100);\nmodel = fitmethod(y)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"This produces a custom model type, TimeVaryingAR that internally stores a vector of ContinuousRoots.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"note: Note\nTimeWindow currently only supports fitmethod LS.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Accompanying this time-varying model is a time-aware distance, TimeDistance. It contains an inner distance (currently only OptimalTransportRootDistance supported), and some parameters that are specific to the time dimension, example:","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"dist = TimeDistance(\n    inner = OptimalTransportRootDistance(\n        domain = Continuous(),\n        p = 2,\n        weight = simplex_residueweight,\n    ),\n    tp = 2,\n    c = 0.1,\n)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"tp is the same as p but for the time dimension, and c trades off the distance along the time axis with the distance along the frequency axis. A smaller c makes it cheaper to transport mass across time. The frequency axis spans [-π,π] and the time axis is the non-negative integers, which should give you an idea for how to make this trade-off.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Below, we construct a signal that changes frequency after half the time, and measure the distance between two different such signals. If the time penalty is large, it is cheaper to transport mass along the frequency axis, but if we make c smaller, after a while the transport is cheaper along the time dimension","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"# Construct a signal that changes freq after half\nsignal(f1,f2) = [sin.((0:0.1:49.9).*f1);sin.((50:0.1:99.9).*f2)]\nfm = TimeWindow(LS(na=2), 500, 0)\nm = signal(1,2)  |> fm # Signal 1\nm2 = signal(2,1) |> fm # Signal 2 has the reverse frequencies\n\n# First it is expensive to transport along time\ndist = TimeDistance(\n    inner = OptimalTransportRootDistance(\n        domain = Continuous(),\n        p      = 1,\n        weight = simplex_residueweight,\n    ),\n    tp = 1,\n    c  = 1.0, # c is large\n)\nevaluate(dist, m, m2)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Then we make it cheaper","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"dist = TimeDistance(\n    inner = OptimalTransportRootDistance(\n        domain = Continuous(),\n        p      = 1,\n        weight = simplex_residueweight,\n    ),\n    tp = 1,\n    c  = 0.01, # c is small\n)\nevaluate(dist, m, m2)","category":"page"},{"location":"time/#Chirp-example-1","page":"Time-Frequency distances","title":"Chirp example","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Here we consider the estimation of the distance between two signals containing chirps, where the onset of the chirp differs. We start by creating some signals with different chirp onsets:","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"fs = 100000\nT = 3\nt = 0:1/fs:T\nN = length(t)\nf = range(1000, stop=10_000, length=N)\nchirp0 = sin.(f.*t)\nfunction chirp(onset)\n    y = 0.1sin.(20_000 .* t)\n    inds = max(round(Int,fs*onset), 1):N\n    y[inds] .+= chirp0[1:length(inds)]\n    y\nend\nusing DSP\nplot(spectrogram(chirp(0), window=hanning), layout=2)\nplot!(spectrogram(chirp(1), window=hanning), sp=2)\nsavefig(\"chirps.html\"); nothing # hide","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"<object type=\"text/html\" data=\"../chirps.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"We then define the fit method and the distance, similar to previous examples","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"fm     = TimeWindow(LS(na=4, λ=1e-4), 20000, 0)\nm      = chirp(1) |> fm # This is the signal we'll measure the distance to\nonsets = LinRange(0, 2, 21) # A vector of onset times\ncv     = exp10.(LinRange(-3, -0.5, 6)); # a vector of `c` values for the time-transport cost","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"We now calculate the distance to the base signal for varying onsets and varying time-transport costs.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"dists = map(Iterators.product(cv, onsets)) do (c, onset)\n    m2 = chirp(onset) |> fm\n    dist = TimeDistance(\n        inner = OptimalTransportRootDistance(\n            domain = Continuous(),\n            p      = 1,\n            weight = simplex_residueweight,\n        ),\n        tp = 1,\n        c  = c,\n    )\n    evaluate(\n        dist,\n        change_precision(Float64, m),  # we reduce the precision for faster computations\n        change_precision(Float64, m2),\n        iters = 10000,\n        tol = 1e-2, # A coarse tolerance is okay for this example\n    )\nend\n\nplot(onsets, dists',\n    lab      = cv',\n    line_z   = log10.(cv)',\n    color    = :inferno,\n    legend   = false,\n    colorbar = true,\n    xlabel   = \"Onset [s]\",\n    title    = \"Distance as function of onset and time cost\"\n)\nsavefig(\"chirp_dists.html\"); nothing # hide","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"The results are shown below. The figure indicates the cost log10(c) using the color scale. We can see that the distance between the signals is smallest at onset=1, which was the onset for the base signal. We also see that for small values of c, it's cheap to transport along time. After increasing c for a while it stops getting more expensive, indicating that it's now cheaper to transport along the frequency axis instead.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"<object type=\"text/html\" data=\"../chirp_dists.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"In this example, we chose the weight function simplex_residueweight, which ensures that each time step has the same amount of spectral mass. Individual poles will still have different masses within each timestep, as determined by the pole's residue.","category":"page"},{"location":"time/#Dynamic-Time-Warping-1","page":"Time-Frequency distances","title":"Dynamic Time Warping","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"This package interfaces with DynamicAxisWarping.jl and provides optimized methods for DynamicAxisWarping.dtwnn. Below is an example of how to search for a query pattern Qm in a much longer pattern Ym","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"searchresult = dtwnn(\n    Qm,\n    Ym,\n    OptimalTransportRootDistance(p = 1, weight = simplex_residueweight),\n    rad,\n    saveall = true,\n    tol = 1e-3,\n)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Both Qm and Ym are expected to be of type TimeVaryingAR.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"DynamicAxisWarping.dtwnn(q::TimeVaryingAR, y::TimeVaryingAR, dist, rad::Int)","category":"page"},{"location":"time/#DynamicAxisWarping.dtwnn-Tuple{TimeVaryingAR,TimeVaryingAR,Any,Int64}","page":"Time-Frequency distances","title":"DynamicAxisWarping.dtwnn","text":"DynamicAxisWarping.dtwnn(q::TimeVaryingAR, y::TimeVaryingAR, dist, rad::Int, args...; kwargs...)\n\nWrapper for dtwnn. To save allocations between multiple calls to dtwnn, you may manually create a helper object and call\n\nusing DynamicAxisWarping\nh = DTWHelper(dist, q, y)\ndtwnn(h, rad::Int, args...; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"time/#Distance-profile-1","page":"Time-Frequency distances","title":"Distance profile","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"A distance profile between a query pattern Qm and a much longer pattern Ym can be computed efficiently with (example)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"dist = TimeDistance(\n    inner = OptimalTransportRootDistance(p = 1, β = 0.5, weight = simplex_residueweight),\n    tp    = 1,\n    c     = 0.1,\n)\nres_tt = distance_profile(dist, Qm, Ym, tol=1e-3)","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Both Qm and Ym are expected to be of type TimeVaryingAR.","category":"page"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"SlidingDistancesBase.distance_profile(od::TimeDistance, q::TimeVaryingAR, y::TimeVaryingAR)","category":"page"},{"location":"time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance,TimeVaryingAR,TimeVaryingAR}","page":"Time-Frequency distances","title":"SlidingDistancesBase.distance_profile","text":"distance_profile(od::TimeDistance, q::TimeVaryingAR, y::TimeVaryingAR; normalize_each_timestep = false, kwargs...)\n\nOptimized method to compute the distance profile corresponding to sliding the short query q over the longer y.\n\n\n\n\n\n","category":"method"},{"location":"time/#Docstrings-1","page":"Time-Frequency distances","title":"Docstrings","text":"","category":"section"},{"location":"time/#","page":"Time-Frequency distances","title":"Time-Frequency distances","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"time.jl\"]","category":"page"},{"location":"time/#SpectralDistances.TimeDistance","page":"Time-Frequency distances","title":"SpectralDistances.TimeDistance","text":"This is a time-aware distance. It contains an inner distance (currently only OptimalTransportRootDistance supported), and some parameters that are specific to the time dimension, example:\n\ndist = TimeDistance(\n    inner = OptimalTransportRootDistance(\n        domain = Continuous(),\n        p      = 2,\n        weight = simplex_residueweight,\n    ),\n    tp = 2,\n    c  = 0.1,\n)\n\ntp is the same as p but for the time dimension, and c trades off the distance along the time axis with the distance along the frequency axis. A smaller c makes it cheaper to transport mass across time. The frequency axis spans [-π,π] and the time axis is the non-negative integers, which should give you an idea for how to make this trade-off.\n\n\n\n\n\n","category":"type"},{"location":"time/#SpectralDistances.TimeVaryingAR","page":"Time-Frequency distances","title":"SpectralDistances.TimeVaryingAR","text":"TimeVaryingAR{T <: AbstractRoots} <: AbstractModel\n\nThis model represents a rational spectrogram, i.e., a rational spectrum that changes with time. See TimeWindow for the corresponding fit method and TimeDistance for a time-aware distance.\n\nInternally, this model stores a vector of AR.\n\n\n\n\n\n","category":"type"},{"location":"time/#SpectralDistances.TimeWindow","page":"Time-Frequency distances","title":"SpectralDistances.TimeWindow","text":"We define a custom fit method for fitting time varying spectra, TimeWindow. It takes as arguments an inner fitmethod, the number of points that form a time window, and the number of points that overlap between two consecutive time windows:\n\nExample\n\nfitmethod = TimeWindow(TLS(na=2), 1000, 500)\ny = sin.(0:0.1:100);\nmodel = fitmethod(y)\n\n\n\n\n\n","category":"type"},{"location":"interpolations/#Interpolations-and-Barycenters-1","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"","category":"section"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Some distances distance define the existence of a shortest path, a geodesic. An interpolation is essentially a datapoint on that shortest path. We provide some functionality to interpolate between different spectra and models under transport-based metrics.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Below is an example usage of interpolations. We initially create two random systems, we then define the distance under which to interpolate and then calculate the frequency response for some different values of the interpolation parameter t in (01)","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"using SpectralDistances, ControlSystems, Distances, Plots, Random\nplotly()\nRandom.seed!(0)\n\nn = 4\nr1 = complex.(-0.01 .+ 0.001randn(3), 2randn(3))\nr1 = ContinuousRoots([r1; conj.(r1)])\n\nr2 = complex.(-0.01 .+ 0.001randn(3), 2randn(3))\nr2 = ContinuousRoots([r2; conj.(r2)])\n\nr1,r2 = normalize_energy.((r1, r2))\n\nA1 = AR(r1)\nA2 = AR(r2)\n\n##\nfig1   = plot()\nt      = 0.1\ndist   = RationalOptimalTransportDistance(domain=Continuous(), p=2, interval=(0., exp10(1.01)))\ninterp = SpectralDistances.interpolator(dist, A1, A2)\nw      = exp10.(LinRange(-1.5, 1, 300))\nfor t = LinRange(0, 1, 7)\n    Φ = clamp.(interp(w,t), 1e-10, 100)\n    plot!(w, sqrt.(Φ), xscale=:log10, yscale=:log10, line_z = t, lab=\"\", xlabel=\"\", title=\"W_2\", ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)\nend\n\nrdist  = EuclideanRootDistance(domain                           =Continuous(), p=2)\ninterp = SpectralDistances.interpolator(rdist, A1, A2, normalize=false)\nfig2   = plot()\nfor t = LinRange(0, 1, 7)\n    Φ = interp(w,t)\n    plot!(w, sqrt.(Φ), xscale=:log10, yscale=:log10, line_z = t, lab=\"\", xlabel=\"\", title=\"RD\", ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)\nend\n\nfig3 = plot()\nΦ1   = bode(tf(A1), w)[1][:]\nΦ2   = bode(tf(A2), w)[1][:]\nfor t = LinRange(0, 1, 7)\n    plot!(w, (1-t).*Φ1 .+ t.*Φ2, xscale=:log10, yscale=:log10, line_z = t, lab=\"\", xlabel=\"Frequency\", title=\"L_2\", ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)\nend\n\nfig = plot(fig1, fig2, fig3, layout=(3,1))\nsavefig(\"interpolation.html\"); nothing # hide","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"<object type=\"text/html\" data=\"../interpolation.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"interpolations/#Barycenters-1","page":"Interpolations and Barycenters","title":"Barycenters","text":"","category":"section"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"A barycenter is a generalization the the arithmetic mean to metrics other than the Euclidean. A barycenter between models is calculated like this","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"bc = barycenter(distance, models)","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"It can be useful to provide some options to the solvers:","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"options = (solver=sinkhorn_log!, tol=1e-8, iters=1_000_000, γ=0.0, uniform=true, inneriters=500_000, innertol=1e-6)\ndistance = OptimalTransportRootDistance(domain=Continuous(), p=2, β=0.01, weight=simplex_residueweight)\nbc = barycenter(distance, models; options...)","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"We can plot the barycenters:","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"using SpectralDistances, ControlSystems, Plots\nmodels   = examplemodels(3)\ndistance = OptimalTransportRootDistance(domain=Continuous())\nbc       = barycenter(distance, models)\nw        = exp10.(LinRange(-0.5, 0.5, 350)) # Frequency vector\nG        = tf.(models) # Convert models to transfer functions from ControlSystems.jl\nplot()\nbodeplot!.(G, Ref(w), plotphase=false, lab=\"Input models\", linestyle=:auto)\nbodeplot!(tf(bc), w, plotphase=false, lab=\"Barycenter\", xscale=:identity, c=:green)\nsavefig(\"barycenter.html\"); nothing # hide","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"<object type=\"text/html\" data=\"../barycenter.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"interpolations/#Barycenters-between-spectrograms-1","page":"Interpolations and Barycenters","title":"Barycenters between spectrograms","text":"","category":"section"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"We can also calculate a barycenter between spectrograms (or arbitrary matrices) using an efficient convolutional method. The most important parameter to tune in order to get a good result, apart from the regularization parameter β, is the dynamic_floor. This parameter determines where (in log space) the floor of the PSD is. This serves as a denoising, why the barycenter appears with a very dark background in the image below.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"using SpectralDistances, DSP, Plots\nN     = 24_000\nt     = 1:N\nf     = range(0.8, stop=1.2, length=N)\ny1    = sin.(t .* f) .+ 0.1 .* randn.()\ny2    = sin.(t .* reverse(f .+ 0.5)) .+ 0.1 .* randn.()\nS1,S2 = spectrogram.((y1,y2), 1024)\n\nA = [S1,S2]\nβ = 0.0001     # Regularization parameter (higher implies more smoothing and a faster, more stable solution)\nλ = [0.5, 0.5] # Barycentric coordinates (must sum to 1)\nB = barycenter_convolutional(A, β=β, tol=1e-6, iters=2000, ϵ=1e-100, dynamic_floor=-2)\nplot(\n    plot(S1, title=\"S1\"),\n    plot(B, title=\"Barycenter\"),\n    plot(S2, title=\"S2\"),\n    layout=(1,3),\n    colorbar=false\n)\n\nsavefig(\"barycenter_sg.html\"); nothing # hide","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"<object type=\"text/html\" data=\"../barycenter_sg.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Note that in order to calculate the barycenter, the sum of each input spectrogram is normalized.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"This function works for any vector of matrices as long as all entries are positive and each matrix has an equal sum.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"For a more thourogh example, see whistle.jl.","category":"page"},{"location":"interpolations/#Trade-off-between-frequency-and-time-1","page":"Interpolations and Barycenters","title":"Trade off between frequency and time","text":"","category":"section"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"There is currently no way of having different costs between transport in time and transport along the frequency axis other than to change the resolution of the spectrogram.","category":"page"},{"location":"interpolations/#K-Barycenters-1","page":"Interpolations and Barycenters","title":"K-Barycenters","text":"","category":"section"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Below, we show an example of how one can run the K-barycenter algorithm on a collection of sound signals. sounds is expected to be of type Vector{Vector{T}}. The example further assumes that there is a vector of labels::Vector{Int} that contain the true classes of the datapoints, which you do not have in an unsupervised setting.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"using SpectralDistances, ControlSystems\nfitmethod = TLS(na=12)\nmodels = SpectralDistances.fitmodel.(fitmethod, sounds)\nG = tf.(models) # Convert to transfer functions for visualization etc.\n\n##\nusing Clustering\ndist = OptimalTransportRootDistance(domain=Continuous(), β=0.01, weight=simplex_residueweight)\n@time clusterresult = SpectralDistances.kbarycenters(\n    dist,\n    models,\n    n_classes, # number of clusters\n    seed       = :rand,\n    solver     = sinkhorn_log!,\n    tol        = 2e-6,\n    innertol   = 2e-6,\n    iters      = 100000,\n    inneriters = 100000,\n    verbose    = true,\n    output     = :best,\n    uniform    = true,\n    kiters     = 10\n)\n\nbc,ass = clusterresult.barycenters, clusterresult.assignments\n\n# Visualize results\nusing MLBase, Plots.PlotMeasures, AudioClustering\nnewass,perm = AudioClustering.associate_clusters(labels,ass)\nclassinds   = 1:n_classes\nyt          = (classinds, [label_strings[findfirst(labels .== i)] for i in classinds])\n\n@show mean(labels .== newass)\ncm = confusmat(n_classes,labels,newass)\nheatmap(cm./sum(cm,dims=2), xlabel=\"Cluster assignment\",ylabel=\"Best matching class\", color=:viridis)\nanns = [(reverse(ci.I)..., text(val,12,:gray)) for (ci,val) in zip(CartesianIndices(cm)[:], vec(cm))]\nannotate!(anns)\nyticks!(yt)\nxticks!(yt, xrotation=45)\ncurrent()","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"The figure should look like the last figure in the paper.","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Pages = [\"interpolations.md\"]\nOrder   = [:type, :function, :macro, :constant]","category":"page"},{"location":"interpolations/#","page":"Interpolations and Barycenters","title":"Interpolations and Barycenters","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"interpolations.jl\", \"barycenter.jl\", \"kbarycenters.jl\"]","category":"page"},{"location":"interpolations/#SpectralDistances.interpolator-Tuple{RationalOptimalTransportDistance,Any,Any}","page":"Interpolations and Barycenters","title":"SpectralDistances.interpolator","text":"interpolator(d, A1, A2)\n\n\nPerform displacement interpolation between two models.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.ISA","page":"Interpolations and Barycenters","title":"SpectralDistances.ISA","text":"ISA(X, w = nothing; iters = 100, printerval = typemax(Int))\n\nIterative swapping algorithm from \"On the Computation of Wasserstein barycenters\", Giovanni Puccetti et al.\n\nArguments:\n\nX: vector of d×k matrices where d is dimension and k number of atoms\nw: weights. See the files test_barycenter.jl for different uses.\niters: maximum number of iterations\nprinterval: print this often\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#SpectralDistances.barycenter","page":"Interpolations and Barycenters","title":"SpectralDistances.barycenter","text":"barycenter(d::OptimalTransportRootDistance, models; normalize = true, kwargs...)\n\nbarycenter(d, models)\nbarycenter(d, models, λ; normalize, uniform, solver, kwargs...)\n\n\nApproximately calculate the barycenter supported on the same number of atoms as the number of poles in the models.\n\nThe solver can be selected by providing a keword argument, example: solver=IPOT.\n\nUses the algorithms from \"Fast Computation of Wasserstein Barycenters\"\n\nExample:\n\nmodels = examplemodels(10)\n\nd = OptimalTransportRootDistance(domain=SpectralDistances.Continuous(),p=2, weight=residueweight, β=0.01)\nXe = barycenter(d, models, solver=sinkhorn_log!, uniform=true)\n\nplot()\npzmap!.(models)\npzmap!(tf(Xe), m=:c, title=\"Barycenter OptimalTransportRootDistance\", lab=\"BC\")\n\nArguments:\n\nmodels: vector of AR models\nnormalize: make sure weights sum to 1\nkwargs: are sent to the solver\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#SpectralDistances.barycenter-Tuple{Array{#s65,1} where #s65<:AbstractArray,Any}","page":"Interpolations and Barycenters","title":"SpectralDistances.barycenter","text":"barycenter(X::Vector{<:AbstractArray}, λ)\n\nCalculate the weighted barycenter for point clouds in X. Each X[i] has the shame n_dims × n_atoms λ is the weight vector that should sum to 1.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.barycenter-Tuple{EuclideanRootDistance,AbstractArray{T,1} where T}","page":"Interpolations and Barycenters","title":"SpectralDistances.barycenter","text":"barycenter(d::EuclideanRootDistance, models::AbstractVector, [λ])\n\nExample:\n\nmodels = examplemodels(10)\n\nXe = barycenter(EuclideanRootDistance(domain=SpectralDistances.Continuous(),p=2), models)\n\nG = tf.(models)\nplot()\npzmap!.(G)\npzmap!(tf(Xe), m=:c, title=\"Barycenter EuclideanRootDistance\")\ncurrent()\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.barycenter_convolutional","page":"Interpolations and Barycenters","title":"SpectralDistances.barycenter_convolutional","text":"barycenter_convolutional(models::Vector{<:DSP.Periodograms.TFR}, λ = Fill(1 / length(models), length(models)); dynamic_floor = mean(log(quantile(power(m), 0.2)) for m in models), kwargs...)\n\nCovenience function for the calculation of spectrograms. This function transforms the spectrograms to log-power and adjusts the floor to dynamic_floor, followed by a normalization to sum to 1.\n\nThis function will be called if barycenter is called with ConvOptimalTransportDistance as first argument.\n\nArguments:\n\ndynamic_floor: Sets the floor of the spectrogram in log-domain, i.e., all values below this will be truncated. The default value is based on a quantile of the spectrogram powers. If your spectrograms are mostly low entropy, you can try to increase this number to get sharper results.\nkwargs: Same as for the base method\n\nExample:\n\nusing SpectralDistances, DSP, Plots\nN     = 24_000\nt     = 1:N\nf     = range(0.8, stop=1.2, length=N)\ny1    = sin.(t .* f) .+ 0.1 .* randn.()\ny2    = sin.(t .* reverse(f .+ 0.5)) .+ 0.1 .* randn.()\nS1,S2 = spectrogram.((y1,y2), 1024)\n\nA = [S1,S2]\nβ = 0.0001     # Regularization parameter (higher implies more smoothing and a faster, more stable solution)\nλ = [0.5, 0.5] # Barycentric coordinates (must sum to 1)\nB = barycenter_convolutional(A, β=β, tol=1e-6, iters=200, ϵ=1e-100, dynamic_floor=-2)\nplot(plot(S1, title=\"S1\"), plot(B, title=\"Barycenter\"), plot(S2, title=\"S2\"), layout=(1,3), colorbar=false)\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#SpectralDistances.barycenter_convolutional-Union{Tuple{TK}, Tuple{T}, Tuple{BCWorkspace{T,TK},AbstractArray{#s61,1} where #s61<:(AbstractArray{T,2} where T)}, Tuple{BCWorkspace{T,TK},AbstractArray{#s31,1} where #s31<:(AbstractArray{T,2} where T),Any}} where TK where T","page":"Interpolations and Barycenters","title":"SpectralDistances.barycenter_convolutional","text":"barycenter_convolutional(A, [λ]; β = 0.01, iters = 1000, tol = 1e-9, ϵ = 1e-90, verbose = false)\n\nConvolutional barycenters.\n\n´βis the regularization andλ(optional) are the weights (barycentric coordinates). To reuse allocated space between successive calls, use the \"workspace\" method from the example below.ϵ` is a truncation parameter for numerical stability.\n\na1      = zeros(10, 10)\na1[2,2] = 1\na2      = zeros(10, 10)\na2[6,6] = 1\nA       = [a1,a2]\nβ       = 0.01\nλ       = [0.5, 0.5] # Barycentric coordinates, must sum to 1\nw       = BCWorkspace(A, β)\nb       = barycenter_convolutional(w,A,λ)\nplot(heatmap(a1), heatmap(a2), heatmap(b))\n\nRef: J. Solomon, F. de Goes, G. Peyré, M. Cuturi, A. Butscher, A. Nguyen, T. Du, L. Guibas. Convolutional Wasserstein Distances: Efficient Optimal Transportation on Geometric Domains.  2015 https://people.csail.mit.edu/jsolomon/assets/convolutional_w2.compressed.pdf\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.barycentric_coordinates-Union{Tuple{T}, Tuple{Any,Any,Any,AbstractArray{T,1}}, Tuple{Any,Any,Any,AbstractArray{T,1},Any}} where T","page":"Interpolations and Barycenters","title":"SpectralDistances.barycentric_coordinates","text":"λ = barycentric_coordinates(pl, ql, p, q; options, kwargs...)\n\nCompute the barycentric coordinates λ such that sum(λᵢ W(pᵢ,q) for i in eachindex(p)) is minimized.\n\nThis function works best with the sinkhorn_log! solver, a large β (around 1) and small tolerance. These are set using kwargs....\n\nArguments:\n\npl: Atoms in measures p, vector, length n_measures, of matrices of size n_dims × n_atoms\nql: Atoms in measure q\np: Measures p, a matrix of weight vectors, size n_atoms × n_measures that sums to 1\nq: the veight vector for measure q, length is n_atoms\noptions: For the Optim solver. Defaults are options = Optim.Options(store_trace=false, show_trace=false, show_every=0, iterations=20, allow_f_increases=true, time_limit=100, x_tol=1e-5, f_tol=1e-6, g_tol=1e-6, f_calls_limit=0, g_calls_limit=0)\nsolver: = sinkhorn_log! solver\ntol:    = 1e-7 tolerance\nβ:      = 0.1 entropy regularization. This function works best with rather large regularization, hence the large default value.\nkwargs: these are sent to the solver algorithm.\n\nExample:\n\nusing SpectralDistances, ControlSystems, Optim\nmodels = examplemodels(10)\n\nd = OptimalTransportRootDistance(\n    domain = SpectralDistances.Continuous(),\n    p      = 2,\n    weight = residueweight,\n    β      = 0.01,\n)\nXe = barycenter(d, models, solver=sinkhorn_log!)\n\nG = tf.(models)\nplot()\npzmap!.(G)\npzmap!(tf(Xe), m=:c, title=\"Barycenter OptimalTransportRootDistance\", lab=\"BC\")\n\noptions = Optim.Options(store_trace       = true,\n                        show_trace        = false,\n                        show_every        = 1,\n                        iterations        = 50,\n                        allow_f_increases = true,\n                        time_limit        = 100,\n                        x_tol             = 1e-7,\n                        f_tol             = 1e-7,\n                        g_tol             = 1e-7,\n                        f_calls_limit     = 0,\n                        g_calls_limit     = 0)\n\n\nmethod = LBFGS()\nλ = barycentric_coordinates(d, models, Xe, method,\n    options = options,\n    solver  = sinkhorn_log!,\n    robust  = true,\n    uniform = true,\n    tol     = 1e-6,\n)\nbar(λ, title=\"Barycentric coorinates\")\n\nG = tf.(models)\nplot()\npzmap!.(G, lab=\"\")\npzmap!(tf(Xe), m = :c, title = \"Barycenter OptimalTransportRootDistance\", lab = \"BC\")\n# It's okay if the last system dot does not match the barycenter exactly, there are limited models to choose from.\npzmap!(G[argmax(λ)], m = :c, lab = \"Largest bc coord\", legend = true)\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.embedding-Tuple{Type{Array{T,1} where T},Any,Vararg{Any,N} where N}","page":"Interpolations and Barycenters","title":"SpectralDistances.embedding","text":"embedding([::Type{Vector}], m, [full=true])\n\nReturns a Vector/Matrix containing the roots of m. full indicates whether or not to use all poles or only one half-plane.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.kbarycenters-Tuple{Any,Any,Any}","page":"Interpolations and Barycenters","title":"SpectralDistances.kbarycenters","text":"kbarycenters(X, p, k; seed = :rand, kiters = 10, verbose = false, output = :best, kwargs...)\n\nClustering using K-barycenters. If you want to cluster spectra, consider the method that accepts models instead.\n\nArguments:\n\nX: Support of input measures, Vector{Matrix} where each matrix is ndims×natoms\np: Weights of input measures Vector{Vector} where each matrix is of length n_atoms and should sum to 1.\nk: number of clusters\nseed: :rand or :eq\nkiters: number of iterations\nverbose: print stuff?\noutput: output lowest cost clustering or :latest?\nkwargs: are sent to the inner solvers.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#SpectralDistances.kbarycenters-Tuple{OptimalTransportRootDistance,Array{#s18,1} where #s18<:SpectralDistances.AbstractModel,Any}","page":"Interpolations and Barycenters","title":"SpectralDistances.kbarycenters","text":"kbarycenters(d::OptimalTransportRootDistance, models::Vector{<:AbstractModel}, k; normalize = true, kwargs...)\n\nThis function is only available if using Clustering.\n\nExample:\n\nclusterresult = kbarycenters(\n    dist,\n    models,\n    k,         # number of clusters\n    seed       = :rand,\n    solver     = sinkhorn_log!,\n    tol        = 2e-6,\n    innertol   = 2e-6,\n    iters      = 100000,\n    inneriters = 100000,\n    verbose    = true,\n    output     = :best,\n    uniform    = true,\n    kiters     = 10\n)\n\nThe docs contain a more detailed example\n\nArguments:\n\nmodels: A vector of models\nk: number of clusters\nnormalize: Whether or not to normalize the weight vectors (recommended)\nkwargs: are sent to inner solvers, (solver,tol,iters)\n\n\n\n\n\n","category":"method"},{"location":"misc/#Misc.-1","page":"Misc.","title":"Misc.","text":"","category":"section"},{"location":"misc/#","page":"Misc.","title":"Misc.","text":"This section lists some convenience utilities for normalization and projection of data.","category":"page"},{"location":"misc/#","page":"Misc.","title":"Misc.","text":"Pages = [\"misc.md\"]\nOrder   = [:type, :function, :macro, :constant]","category":"page"},{"location":"misc/#","page":"Misc.","title":"Misc.","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"misc/#SpectralDistances.n1-Tuple{Any}","page":"Misc.","title":"SpectralDistances.n1","text":"n1(x)\n\nnormalize x norm 1\n\n\n\n\n\n","category":"method"},{"location":"misc/#SpectralDistances.s1","page":"Misc.","title":"SpectralDistances.s1","text":"s1(x, dims=:)\n\nnormalize x sums to 1\n\n\n\n\n\n","category":"function"},{"location":"misc/#SpectralDistances.threeD-Tuple{Any}","page":"Misc.","title":"SpectralDistances.threeD","text":"threeD(X)\n\nProject X to three dimensions using PCA\n\n\n\n\n\n","category":"method"},{"location":"misc/#SpectralDistances.twoD-Tuple{Any}","page":"Misc.","title":"SpectralDistances.twoD","text":"twoD(X)\n\nProject X to two dmensions using PCA\n\n\n\n\n\n","category":"method"},{"location":"misc/#SpectralDistances.v1","page":"Misc.","title":"SpectralDistances.v1","text":"v1(x, dims=:)\n\nnormalize x var 1\n\n\n\n\n\n","category":"function"},{"location":"distances/#Distances-1","page":"Distances","title":"Distances","text":"","category":"section"},{"location":"distances/#Overview-1","page":"Distances","title":"Overview","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The following is a reference for all the distances defined in this package. Once a distance object is defined, it can be evaluated in one of two ways, defined by the  Distances.jl interface","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"dist = DistanceType(options)\nd = evaluate(d, x1, x2; kwargs...) # keyword arguments are used to control the solvers for some transport-based distances\nd = dist(x1, x2) # A shorter syntax for calling the distance","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"note: Note\nAll distances return the distance raised to the power p, thus RationalOptimalTransportDistance(p=2)(x1,x2) = W_2(x_1x_2)^2 where W_2 denotes the Wasserstein distance of order 2.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Before we proceed, we list a number of classes of distances that are available","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Pages = [\"distances.md\"]\nOrder   = [:type]","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"using SpectralDistances, InteractiveUtils, DSP","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Some of these distances operate directly on signals, these are","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"foreach(println, subtypes(SpectralDistances.AbstractSignalDistance)) # hide","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Of these, ModelDistance is a bit special, works like this","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"ModelDistance","category":"page"},{"location":"distances/#SpectralDistances.ModelDistance","page":"Distances","title":"SpectralDistances.ModelDistance","text":"ModelDistance{D <: AbstractDistance} <: AbstractSignalDistance\n\nA model distance operates on signals and works by fitting an LTI model to the signals before calculating the distance. The distance between the LTI models is defined by the field distance. This is essentially a wrapper around the inner distance that handles the fitting of a model to the signals. How the model is fit is determined by fitmethod.\n\nArguments:\n\nfitmethod::FitMethod: LS, TLS or PLR\ndistance::D: The inner distance between the models\n\nExample:\n\nusing SpectralDistances\ninnerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)\ndist = ModelDistance(TLS(na=30), innerdistance)\n\n\n\n\n\n","category":"type"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The inner distance in ModelDistance can be any AbstractRationalDistance. The options are","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"foreach(println, subtypes(SpectralDistances.AbstractRationalDistance)) # hide","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"These distances operate on LTI models. Some operate on the coefficients of the models","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"foreach(println, subtypes(SpectralDistances.AbstractCoefficientDistance)) # hide","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"and some operate on the roots of the models","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"foreach(println, subtypes(SpectralDistances.AbstractRootDistance)) # hide","category":"page"},{"location":"distances/#A-full-example-1","page":"Distances","title":"A full example","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"To use the OptimalTransportRootDistance and let it operate on signals, we may construct our distance object as follows","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"innerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)\ndist = ModelDistance(TLS(na=10), innerdistance)\nX1, X2 = randn(1000), randn(1000);\ndist(X1,X2)\n\ndist = ModelDistance(LS(na=2), innerdistance);\nt = 0:0.01:10;\nX1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency\ndist(X1,X2)\nX1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency\ndist(X1,X2)","category":"page"},{"location":"distances/#Using-Welch-periodograms-1","page":"Distances","title":"Using Welch periodograms","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"We can calculate the Wasserstein distance between spectra estimated using the Welch method like so","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"dist = WelchOptimalTransportDistance(p=2)\nX1, X2 = randn(1000), randn(1000);\ndist(X1,X2)\nt = 0:0.01:10;\nX1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency\ndist(X1,X2)\nX1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency\ndist(X1,X2)","category":"page"},{"location":"distances/#Gradients-1","page":"Distances","title":"Gradients","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Some distances will allow you to propagate gradients through them. Below is an example using Zygote and the OptimalTransportRootDistance","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"using Zygote\nZygote.@nograd rand # Currently needed woraround\nx1 = SpectralDistances.bp_filter(randn(100000), (0.1,0.3))  # Create two signals\nx2 = SpectralDistances.bp_filter(randn(100000), (0.1,0.2))\nfm = LS(na=10)      # LS is the best supported fitmethod for gradients\n\ndist = ModelDistance(fm,OptimalTransportRootDistance(domain = Continuous()))      # Since we're measureing distance between signals, we wrap the distance in a ModelDistance","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"dist(x1,x2)\n∇x1 = Zygote.gradient(x->real(evaluate(dist,x,x2)), x1)[1] # The call to real is a workaround for a Zygote bug","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The differentiation takes some time, but it should be fast enough to be generally useful for gradient-based learning of autoencoders etc. The following is a benchmark performed on an old laptop without GPU (the distances are not yet tested on GPUs)","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"@btime Zygote.gradient(x->real(evaluate($dist,x,$x2)), $x1);\n#  134.965 ms (107566 allocations: 134.77 MiB)","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"with a precomputed reference model, it goes even faster","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"m2 = fm(x2)\nm2 = change_precision(Float64, m2) # Tihs step is important for performance\n@btime Zygote.gradient(x->real(evaluate($dist,x,$m2)), $x1);\n#  80.200 ms (103437 allocations: 69.62 MiB)","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The same benchmarks performed on a 2019 desktop computer yields the following timings","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"julia> @btime Zygote.gradient(x->real(evaluate($dist,x,$x2)), $x1);\n  45.926 ms (107748 allocations: 136.18 MiB)\n\njulia> @btime Zygote.gradient(x->real(evaluate($dist,x,$m2)), $x1);\n  25.120 ms (103619 allocations: 71.03 MiB)","category":"page"},{"location":"distances/#Unbalanced-transport-1","page":"Distances","title":"Unbalanced transport","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"There are situations in which one would like to avoid fully transporting all mass between two measures. A few such cases are","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The two measures do not have the same mass. In this case, the standard, balanced, optimal-transport problem is unfeasible.\nEnergy is somehow lost or added to one spectra in a way that should not be accounted for by transport. This would be the case if\nSpectral energy is absorbed by a channel through which a signal is propagated. In this case it would not make sense to try to transport mass from the other spectrum away from the absorbed (dampended) frequency.\nSpectral energy is added by a noise source. This energy should ideally not be considered for transport and should rather be destroyed.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"For situations like this, an AbstractDivergence can be supplied to the OptimalTransportRootDistance. This divergence specifies how expensive it is to create or destroy mass in the spectra. The available divergences are listed in the docs of UnbalancedOptimalTransport.jl, to which we outsource the solving of the unbalanced problem. For convenience, the wrapper sinkhorn_unbalanced is available to interface the unbalanced solver in the same way as the solvers from this package are interfaced.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"using DSP\nfm = LS(na = 10);\nm1 = fm(filtfilt(ones(10), [10], randn(1000)));\nm2 = fm(filtfilt(ones(5), [5], randn(1000)));\ndist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=Balanced())\nd1 = evaluate(dist,m1,m2)\ndist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(1.0));\nd2 = evaluate(dist,m1,m2)\ndist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(10.0));\nd3 = evaluate(dist,m1,m2)\ndist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(0.01));\nd4 = evaluate(dist,m1,m2)\nd1 > d3 > d2 > d4","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"When the distance is evaluated the second time, unbalanced transport is used. The d2 should be equal to or smaller than d1. If we make the KL term larger, the distance approaches the balanced cost, and if we make it smaller, it becomes very cheap to create/destroy mass and less mass is transported.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The first case, where divergence=Balanced() was supplied, should be equivalent to not providing any divergence at all. In pratice results might differ slightly since a different solver implementation is used.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Below is an example in which the unbalanced transport between two systems is computed. The two systems do not have the same number of poles, and if destruction of mass is made cheap, not all mass is transported. The thickness of the lines indicate mass flow.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"using Plots\nm1 = AR(Continuous(), [1, 0.1, 1.3])                        |> change_precision(Float64)\nm2 = AR(Continuous(), polyconv([1, 0.1, 1], [1, 0.1, 1.2])) |> change_precision(Float64)\nD  = SpectralDistances.distmat_euclidean(m1.pc, m2.pc)\nw1, w2 = unitweight.((m1, m2))\nfigs = map([0.001, 0.01, 0.1]) do tv\n    divergence = TV(tv)\n    Γ, a, b = sinkhorn_unbalanced(D, w1, w2, divergence, β = 0.01)\n    lineS   = 20Γ\n    lineS[lineS.<0.1] .= 0\n    alphaS  = lineS ./ maximum(lineS)\n    f       = scatter(m1.pc, legend = false, ms = 10, title = \"TV=$tv\")\n    scatter!(m2.pc, ms = 10)\n    for (i, p1) in enumerate(m1.pc), (j, p2) in enumerate(m2.pc)\n        coords = [p1, p2]\n        plot!(\n            real(coords),\n            imag(coords),\n            linewidth = lineS[i, j],\n            alpha     = alphaS[i, j],\n            color     = :black,\n        )\n    end\n    f\nend\nplot(figs..., layout = (1, 3), ylims = (0.9, 1.2))\nsavefig(\"unbalanced_poles.html\"); nothing # hide","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"<object type=\"text/html\" data=\"../unbalanced_poles.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"distances/#Function-reference-1","page":"Distances","title":"Function reference","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Pages = [\"distances.md\"]\nOrder   = [:function, :macro, :constant]","category":"page"},{"location":"distances/#Docstrings-1","page":"Distances","title":"Docstrings","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"losses.jl\", \"sinkhorn.jl\", \"jump.jl\", \"convex.jl\"]","category":"page"},{"location":"distances/#SpectralDistances.AbstractDistance","page":"Distances","title":"SpectralDistances.AbstractDistance","text":"The top level distance type\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.AbstractRationalDistance","page":"Distances","title":"SpectralDistances.AbstractRationalDistance","text":"All subtypes of this type operates on rational transfer functions\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.AbstractSignalDistance","page":"Distances","title":"SpectralDistances.AbstractSignalDistance","text":"All subtypes of this type operates on signals\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.BuresDistance","page":"Distances","title":"SpectralDistances.BuresDistance","text":"BuresDistance <: AbstractDistance\n\nDistance between pos.def. matrices\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.CoefficientDistance","page":"Distances","title":"SpectralDistances.CoefficientDistance","text":"CoefficientDistance{D, ID} <: AbstractCoefficientDistance\n\nDistance metric based on model coefficients\n\nArguments:\n\ndomain::D: Discrete or Continuous\ndistance::ID = SqEuclidean(): Inner distance between coeffs\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.DiscreteGridTransportDistance","page":"Distances","title":"SpectralDistances.DiscreteGridTransportDistance","text":"DiscreteGridTransportDistance{DT} <: AbstractDistance\n\nOptimal transport between two measures on a common discrete grid.\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.DiscretizedRationalDistance","page":"Distances","title":"SpectralDistances.DiscretizedRationalDistance","text":"DiscretizedRationalDistance{WT, DT} <: AbstractRationalDistance\n\nThis distance discretizes the spectrum before performing the calculations.\n\nArguments:\n\nw::WT = LinRange(0.01, 0.5, 300): Frequency set\ndistmat::DT = distmat_euclidean(w, w): DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.EnergyDistance","page":"Distances","title":"SpectralDistances.EnergyDistance","text":"EnergyDistance <: AbstractSignalDistance\n\nstd(x1) - std(x2) This distance can be added to a loss function to ensure that the energy in the two signals is the same. Some of the optimal transport-based distances are invariant to the energy in the signal, requiring this extra cost if that invariance is not desired. Combining distances is done by putting two or more in a tuple.     Usage: combined_loss = (primary_distance, EnergyDistance())\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.EuclideanRootDistance","page":"Distances","title":"SpectralDistances.EuclideanRootDistance","text":"EuclideanRootDistance{D, A, F1, F2} <: AbstractRootDistance\n\nSimple euclidean distance between roots of transfer functions\n\nArguments:\n\ndomain::D: Discrete or Continuous\nassignment::A = SortAssignement(imag): Determines how roots are assigned. An alternative is HungarianAssignement\ntransform::F1 = identity: DESCRIPTION\nweight : A function used to calculate weights for the induvidual root distances. A good option is residueweight\np::Int = 2 : Order of the distance\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.HungarianRootDistance","page":"Distances","title":"SpectralDistances.HungarianRootDistance","text":"HungarianRootDistance{D, ID <: Distances.PreMetric, F} <: AbstractRootDistance\n\nSimilar to EuclideanRootDistance but does the pole assignment using the Hungarian method.\n\nArguments:\n\ndomain::D = Continuous(): Discrete or Continuous\ndistance::ID = SqEuclidean(): Inner distance\ntransform::F = identity: If provided, this Function transforms all roots before the distance is calculated\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.KernelWassersteinRootDistance","page":"Distances","title":"SpectralDistances.KernelWassersteinRootDistance","text":"KernelWassersteinRootDistance{D, F, DI} <: AbstractRootDistance\n\nA kernel version of the root distance\n\nArguments:\n\ndomain::D = Continuous(): Discrete or Continuous\nλ::Float64 = 1.0: Kernel precision, lower value means wider kernel.\ntransform::F = identity: If provided, this Function transforms all roots before the distance is calculated\ndistance::DI = SqEuclidean(): Inner distance\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.OptimalTransportHistogramDistance","page":"Distances","title":"SpectralDistances.OptimalTransportHistogramDistance","text":"OptimalTransportHistogramDistance{DT} <: AbstractDistance\n\nOptimal transport between two histograms. If you pass two vectors to this distance two histograms will be computed automatically (fit(Histogram,x)). Pass two histograms to get better manual control.\n\nArguments:\n\np::Int = 1: order\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.OptimalTransportRootDistance","page":"Distances","title":"SpectralDistances.OptimalTransportRootDistance","text":"OptimalTransportRootDistance{D, F1, F2, S} <: AbstractRootDistance\n\nThe Sinkhorn distance between roots. The weights are provided by weight, which defaults to residueweight.\n\nArguments:\n\ndomain::D = Continuous(): Discrete or Continuous\ntransform::F1 = identity: Probably not needed.\nweight::F2 =simplex_residueweight: A function used to calculate weights for the induvidual root distances.\nβ::Float64 = 0.01: Amount of entropy regularization\np::Int = 2 : Order of the distance\ndivergence::S = nothing: A divergence that penalizes creation and destruction of mass.\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.RationalCramerDistance","page":"Distances","title":"SpectralDistances.RationalCramerDistance","text":"RationalCramerDistance{DT} <: AbstractRationalDistance\n\nSimilar to RationalOptimalTransportDistance but does not use inverse functions.\n\nArguments:\n\ndomain::DT = Continuous(): Discrete or Continuous\np::Int = 2: order\ninterval = (-(float(π)), float(π)): Integration interval\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.RationalOptimalTransportDistance","page":"Distances","title":"SpectralDistances.RationalOptimalTransportDistance","text":"CationalOptimalTransportDistance{DT, MT} <: AbstractRationalDistanCe\n\ncalculates the Wasserstein distance using the closed-form sold*c for (d,c) in zip(D,C)s and inverse cumulative functions.\n\nC ArgumentC:\n\ndomain::DT = Continuous(): Discrete or [Continuous](@red*c for (d,c) in zip(D,C)r\nmagnitude::MT = Identity():\ninterval = (-(float(π)), float(π)): Integration interval\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.SymmetricDistance","page":"Distances","title":"SpectralDistances.SymmetricDistance","text":"SymmetricDistance{D} <: AbstractDistance\n\nEvaluates d(x,y) - 0.5(d(x,x) + d(y,y))\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.WelchLPDistance","page":"Distances","title":"SpectralDistances.WelchLPDistance","text":"WelchLPDistance{AT <: Tuple, KWT <: NamedTuple, F} <: AbstractWelchDistance\n\nLᵖ distance between welch spectra, mean(abs(x1-x2)^p).\n\n#Arguments:\n\nargs::AT = (): These are sent to welch_pgram\nkwargs::KWT = NamedTuple(): These are sent to welch_pgram\np::Int = 2: Order of the distance\nnormalized::Bool = true: Normlize spectrum to sum to 1 (recommended)\ntransform::F = identity: Optional function to apply to the spectrum, example log1p or sqrt. Must not produce negative values, so log is not a good idea. The function is applied like this: transform.(x1).\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.WelchOptimalTransportDistance","page":"Distances","title":"SpectralDistances.WelchOptimalTransportDistance","text":"WelchOptimalTransportDistance{DT, AT <: Tuple, KWT <: NamedTuple} <: AbstractWelchDistance\n\nCalculates the Wasserstein distance between two signals by estimating a Welch periodogram of each.\n\nArguments:\n\ndistmat::DT: you may provide a matrix array for this\nargs::AT = (): Options to the Welch function\nkwargs::KWT = NamedTuple(): Options to the Welch function\np::Int = 2 : Order of the distance\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T","page":"Distances","title":"SpectralDistances.discrete_grid_transportplan","text":"discrete_grid_transportplan(x::AbstractVector{T}, y::AbstractVector{T}, tol=sqrt(eps(T))) where T\n\nCalculate the optimal-transport plan between two vectors that are assumed to have the same support, with sorted support points.\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.distmat-Tuple{Any,AbstractArray{T,1} where T}","page":"Distances","title":"SpectralDistances.distmat","text":"distmat(dist::Any, e::AbstractArray{T,1} where T; normalize, kwargs...) -> LinearAlgebra.Symmetric\n\n\nCompute the symmetric, pairwise distance matrix using the specified distance.\n\nnormalize: set to true to normalize distances such that the diagonal is zero. This is useful for distances that are not true distances due to d(x,y) ≠ 0 such as the OptimalTransportRootDistance\n\nThis function uses multiple threads if available.\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.distmat_euclidean","page":"Distances","title":"SpectralDistances.distmat_euclidean","text":"distmat_euclidean(e1::AbstractVector, e2::AbstractVector, p = 2)\n\nThe euclidean distance matrix between two vectors of complex numbers\n\n\n\n\n\n","category":"function"},{"location":"distances/#SpectralDistances.distmat_euclidean!","page":"Distances","title":"SpectralDistances.distmat_euclidean!","text":"distmat_euclidean!(D, e1::AbstractVector, e2::AbstractVector, p = 2) = begin\n\nIn-place version\n\n\n\n\n\n","category":"function"},{"location":"distances/#SpectralDistances.domain-Tuple{Any}","page":"Distances","title":"SpectralDistances.domain","text":"domain(d::AbstractDistance)\n\ndomain(d::Any) -> Discrete\n\n\nReturn the domain of the distance\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}","page":"Distances","title":"SpectralDistances.domain_transform","text":"domain_transform(d::AbstractDistance, e)\n\nChange domain of roots\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.precompute","page":"Distances","title":"SpectralDistances.precompute","text":"precompute(d::AbstractDistance, As, threads=true)\n\nPerform computations that only need to be donce once when several pairwise distances are to be computed\n\nArguments:\n\nAs: A vector of models\nthreads: Us multithreading? (true)\n\n\n\n\n\n","category":"function"},{"location":"distances/#SpectralDistances.ConvOptimalTransportDistance","page":"Distances","title":"SpectralDistances.ConvOptimalTransportDistance","text":"ConvOptimalTransportDistance <: AbstractDistance\n\nDistance between matrices caluclated using sinkhorn_convolutional.\n\nβ = 0.001\ndynamic_floor = -10.0\n\n\n\n\n\n","category":"type"},{"location":"distances/#SpectralDistances.IPOT","page":"Distances","title":"SpectralDistances.IPOT","text":"Γ, u, v = IPOT(C, a, b; β=1, iters=1000)\n\nThe Inexact Proximal point method for exact Optimal Transport problem (IPOT) (Sinkhorn-like) algorithm. C is the cost matrix and a,b are vectors that sum to one. Returns the optimal plan and the dual potentials. See also sinkhorn. β does not have to go to 0 for this alg to return the optimal distance, in fact, if β is set too low, this alg will encounter numerical problems.\n\nA Fast Proximal Point Method for Computing Exact Wasserstein Distance Yujia Xie, Xiangfeng Wang, Ruijia Wang, Hongyuan Zha https://arxiv.org/abs/1802.04307\n\n\n\n\n\n","category":"function"},{"location":"distances/#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}","page":"Distances","title":"SpectralDistances.sinkhorn","text":"Γ, u, v = sinkhorn(C, a, b; β=1e-1, iters=1000)\n\nThe Sinkhorn algorithm. C is the cost matrix and a,b are vectors that sum to one. Returns the optimal plan and the dual potentials. This function is relatively slow, see also sinkhorn_log! IPOT and sinkhorn_log for faster algorithms.\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}","page":"Distances","title":"SpectralDistances.sinkhorn_log!","text":"Same as sinkhorn_log but operates in-place to save memory allocations. This function has higher performance than sinkhorn_log, but might not work as well with AD libraries.\n\nThis function can be made completely allocation free with the interface     sinkhorn_log(w::SinkhornLogWorkspace{T}, C, a, b; kwargs...)\n\nThe sinkhorn_log! solver also accepts a keyword argument check_interval = 20 that determines how often the convergence criteria is checked. If β is large, the algorithm might converge very fast and you can save some iterations by reducing the check interval. If β is small and the algorithm requires many iterations, a larger number saves you from computing the check too often.\n\nThe workspace w is created linke this: w = SinkhornLogWorkspace(FloatType, length(a), length(b))\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}","page":"Distances","title":"SpectralDistances.sinkhorn_log","text":"Γ, u, v = sinkhorn_log(C, a, b; β=1e-1, iters=1000, tol=1e-8)\n\nThe Sinkhorn algorithm (log-stabilized). C is the cost matrix and a,b are vectors that sum to one. Returns the optimal plan and the dual potentials. See also sinkhorn_log! for a faster implementation operating in-place, and IPOT for a potentially more exact solution.\n\nWhen this function is being differentiated, warnings about inaccurate solutions are turned off. You may choose to manually asses the error in the constrains by ea, eb = SpectralDistances.ot_error(Γ, a, b).\n\nThe IPOT algorithm: https://arxiv.org/pdf/1610.06519.pdf\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}","page":"Distances","title":"SpectralDistances.sinkhorn_unbalanced","text":"Γ, u, v = sinkhorn_unbalanced(C, a, b, divergence; β=1e-1, iters=1000, tol=1e-8)\n\nThe Unbalanced Sinkhorn algorithm (log-stabilized). C is the cost matrix and a,b are vectors that are not required to sum to one.\n\nRef: \"Sinkhorn Divergences for Unbalanced Optimal Transport\" https://arxiv.org/abs/1910.12958 Makes use of UnbalancedOptimalTransport.jl\n\n\n\n\n\n","category":"method"},{"location":"distances/#SpectralDistances.ot_jump-Tuple{Any,Any,Any}","page":"Distances","title":"SpectralDistances.ot_jump","text":"ot_jump(D, P1, P2)\n\nSolve the optimal transport problem using JuMP. This function is only available if using JuMP, GLPK.\n\nArguments:\n\nD: Distance matrix\nP1: Weight vector 1\nP2: Weight vector 2\n\n\n\n\n\n","category":"method"},{"location":"distances/#Details-1","page":"Distances","title":"Details","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"Transport-based distances may require some tuning parameters to be set for the solvers. The available solvers are","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"sinkhorn: not recommended due to numerical issues, but this is the most commonly cited algorithm.\nsinkhorn_log: better numerical stability than the standard.\nsinkhorn_log!: in-place version that is faster, but some AD libraries might not like it (often the default if no solver is provided).\nsinkhorn_unbalanced: this solver accepts a divergence that penalizes creation/destruction of mass. It thus handles measure of different masses and can choose to create/destroy mass instead of transporting it.\nIPOT Finds exact solution (without entropy regularization), requires β around 0.1-1.\not_jump: exact solution using JuMP, requires using JuMP, GLPK before it becomes available.\not_convex: exact solution using Convex.jl, requires using Convex, GLPK before it becomes available.","category":"page"},{"location":"distances/#Providing-solver-and-options-1","page":"Distances","title":"Providing solver and options","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"options = (solver=sinkhorn_log!, tol=1e-6, iters=100_000)\ndistance = OptimalTransportRootDistance(domain=Continuous(), p=1, β=0.001)\nSpectralDistances.evaluate(distance, model1, model2; options...)","category":"page"},{"location":"distances/#Maximum-performance-1","page":"Distances","title":"Maximum performance","text":"","category":"section"},{"location":"distances/#","page":"Distances","title":"Distances","text":"This solver sinkhorn_log! can be made completely allocation free with the interface","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"sinkhorn_log(w::SinkhornLogWorkspace{T}, C, a, b; kwargs...)","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The workspace w is created linke this:","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"w = SinkhornLogWorkspace(eltype(a), length(a), length(b))","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"This will save you both allocations and time if called multiple times, especially important if you intend to make use of multiple threads. For multiple threads, make sure to create one workspace for each thread.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"The sinkhorn_log! solver also accepts a keyword argument check_interval = 20 that determines how often the convergence criteria is checked. If β is large, the algorithm might converge very fast and you can save some iterations by reducing the check interval. If β is small and the algorithm requires many iterations, a larger number saves you from computing the check too often.","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"See also inplace functions","category":"page"},{"location":"distances/#","page":"Distances","title":"Distances","text":"distmat_euclidean!","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Typical-workflows-1","page":"Examples","title":"Typical workflows","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"In this section, we'll demonstrate some common ways of interacting with the package","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"To quickly try things out, you can generate some example models of signals using examplemodels like this models = examplemodels(10).","category":"page"},{"location":"examples/#Calculate-root-embeddings-from-sound-files-1","page":"Examples","title":"Calculate root embeddings from sound files","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"In this example, we'll read a bunch of sound files and calculate embedding vectors containing information about the poles of estimated rational spectra. These embeddings are useful for classification etc. See the paper for further explanation.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This example makes use of a few other packages, notably AudioClustering.jl for some convenience functions.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Glob, WAV, SpectralDistances\nconst fs = 44100\nusing Grep\n##\nusing DSP, LPVSpectral\nusing AudioClustering\n\npath = \"path/to/folder/with/wav-files\"\n\ncd(path)\nfiles     = glob(\"*.wav\")\nlabels0   = match.(r\"[a-z_]+\", files)..:match .|> String # This regex assumes that the files are named in a certain way, you may adopt as needed, or load the labels separately.\nulabels   = unique(labels0)\nlabels    = sum((labels0 .== reshape(ulabels,1,:)) .* (1:30)', dims=2)[:]\nna        = 18 # Order of the models\nfitmethod = LS(na=na, λ=1e-5)\n\nmodels = mapsoundfiles(files, fs) do sound # mapsoundfiles is defined in AudioClustering\n    sound = SpectralDistances.bp_filter(sound, (50/fs, 18000/fs)) # prefiltering is a good idea\n    SpectralDistances.fitmodel(fitmethod, sound)\nend\n\nX = embeddings(models)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"We now have a matrix X with features, we can run clustering on it like this:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Clustering\nlabels,models,X,Z = get_features(trainpath)\ncr = kmeans(v1(X,2), 30) # v1 normalizes mean and variance\n\nPlots.plot(\n    scatter(threeD(X'),\n        marker_z          = labels,\n        m                 = (2, 0.5),\n        markerstrokealpha = 0,\n        colorbar          = false,\n        title             = \"Correct assignment\",\n    ),\n    scatter(threeD(X'),\n        marker_z          = cr.assignments,\n        m                 = (2, 0.5),\n        markerstrokealpha = 0,\n        colorbar          = false,\n        title             = \"K-means on w assignment\",\n    ),\n    legend = false,\n)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Another clustering approach is to use kbarycenters, see example K-Barycenters.","category":"page"},{"location":"examples/#Nearest-Neighbor-classification-1","page":"Examples","title":"Nearest Neighbor classification","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Here, we will classify a signal based on it's nearest neighbor in a training dataset. The example assumes that the matrix X from the previous example is available, and that there is a similar matrix Xt created from a test dataset. We will classify the entries in the test set using the entries in the training set. The example also assumes that there are two vectors labels::Vector{Int} and labelst::Vector{Int} that contain the class labels.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using AMD # For permutation of the confusion matrix to more easily identity similar classes.\nusing MultivariateStats # For whitening transform\n\nfunction knn_classify(labels, X, Xt, k)\n    N    = size(Xt,2)\n    y    = zeros(Int, N)\n    W    = fit(Whitening, X)\n    X    = MultivariateStats.transform(W,X)\n    Xt   = MultivariateStats.transform(W,Xt)\n    tree = NearestNeighbors.KDTree(X)\n    for i in 1:N\n        inds, dists = knn(tree, Xt[:,i], k)\n        y[i]        = mode(labels[inds])\n    end\n    y\nend\n\nyht = knn_classify(labels,X,Xt,1) # look at the single nearest neighbor\n@show mean(labelst .== yht) # This is the accuracy\ncm   = confusmat(30,labelst,yht)\nperm = amd(sparse(cm))\ncm   = cm[perm,perm]\nheatmap(cm./sum(cm,dims=2), xlabel=\"Predicted class\",ylabel=\"True class\", title=\"Confusion Matrix for Test Data\")\nanns = [(reverse(ci.I)..., text(val,8)) for (ci,val) in zip(CartesianIndices(cm)[:], vec(cm))]\nannotate!(anns)","category":"page"},{"location":"examples/#Pairwise-distance-matrix-1","page":"Examples","title":"Pairwise distance matrix","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Many algorithms make use of a matrix containing all pairwise distances between points. Given a set of models, we can easily obtain such a matrix:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"distance = OptimalTransportRootDistance(domain=Continuous())\nD = SpectralDistances.distmat(distance, models)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"with this matrix, we can, for instance, run clustering:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Clustering\ncr = hclust(Symmetric(sqrt.(D)))\nassignments = cutree(cr,k=30) # k is desired number of clusters","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Another clustering approach is to use kbarycenters, see example in the docstring.","category":"page"},{"location":"examples/#Detection-using-examples-1","page":"Examples","title":"Detection using examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"A measure of distance can be used for detection, by selecting a few positive examples and calculating the distance to the nearest neighbor within these examples from a new query point, a simple example:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"function scorefunction(query_model)\n    distance = OptimalTransportRootDistance(domain=Continuous())\n    distance_vector = distance.(Ref(query_model),positive_example_models)\n    score = minimum(distance_vector)\nend","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This can be made significantly more effective (but less accurate) using the knn approach from the Nearest Neighbor classification.","category":"page"},{"location":"examples/#The-closed-form-solution-1","page":"Examples","title":"The closed-form solution","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"In this example we will simply visalize two spectra, the locations of their poles and the cumulative spectrum functions.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using ControlSystems, SpectralDistances, Plots\nplotly(grid=false)\n\nG1   = tf(1,[1,0.12,1])*tf(1,[1,0.1,0.1])\nG2   = tf(1,[1,0.12,2])*tf(1,[1,0.1,0.4])\na1   = denvec(G1)[]\na2   = denvec(G2)[]\nn    = length(a1)\n\nf1c  = w -> abs2(1/sum(j->a1[j]*(im*w)^(n-j), 1:n))\nf2c  = w -> abs2(1/sum(j->a2[j]*(im*w)^(n-j), 1:n))\nsol1 = SpectralDistances.c∫(f1c,0,3π)\nsol2 = SpectralDistances.c∫(f2c,0,3π)\n\nfig1 = plot((sol1.t .+ sol1.t[2]).*2π, sqrt.(sol1 ./ sol1[end]), fillrange=sqrt.(sol2(sol1.t) ./ sol2[end]), fill=(0.6,:purple), l=(2,:blue))\nplot!((sol2.t .+ sol2.t[2]).*2π, sqrt.(sol2(sol2.t) ./ sol2[end]), l=(2,:orange), xscale=:log10, legend=false, grid=false, xlabel=\"Frequency\", xlims=(1e-2,2pi))\n\nfig2 = bodeplot([G1, G2], exp10.(LinRange(-1.5, 1, 200)), legend=false, grid=false, title=\"\", linecolor=[:blue :orange], l=(2,), plotphase=false)\n\nfig3 = pzmap([G1, G2], legend=false, grid=false, title=\"\", markercolor=[:blue :orange], color=[:blue :orange], m=(2,:c), xlims=(-0.5,0.5))\nvline!([0], l=(:black, :dash))\nhline!([0], l=(:black, :dash))\n\nplot(fig1, fig2, fig3, layout=(1,3))\nsavefig(\"cumulative.html\"); nothing # hide","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"../cumulative.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"ltimodels/#Models-and-root-manipulations-1","page":"Models and root manipulations","title":"Models and root manipulations","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"using SpectralDistances, InteractiveUtils, Plots, ControlSystems","category":"page"},{"location":"ltimodels/#Overview-1","page":"Models and root manipulations","title":"Overview","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Most distances available in this package operate on linear models estimated from a time-domain signal. This package supports two kind of LTI models, AR and ARMA. AR represents a model with only poles whereas ARMA has zeros as well. These types are subtypes of ControlSystems.LTISystem, so many of the functions from the ControlSystems.jl toolbox work on these models as well. When acting like a ControlSystems.LTISystem, the default is to use the continuous-time representation of the model. The discrete-time representation can be obtained by tf(m, 1) where 1 is the sample time. More on the time-domain representation below.","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"note: Note\nThis package makes the assumption that the sample time is 1 everywhere. When an AbstractModel is constructed, one must thus take care to rescale the frequency axis accordingly if this does not hold. If the discrete-time representation is never used, this is of no concern.","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"To fit a model to data, one first has to specify a FitMethod, the options are","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"foreach(println, subtypes(SpectralDistances.FitMethod)) # hide","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"For example, to estimate an AR model of order 6 using least-squares, we can do the following","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"data = randn(1000);\nfitmethod = LS(na=6)\nmodel = fitmethod(data)\nchange_precision(Float32, model) # Can be useful to reduce the computational cost of some distances\npzmap(model)\nsavefig(\"pzmap_models.html\"); nothing # hide","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"<object type=\"text/html\" data=\"../pzmap_models.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"ltimodels/#Time-domain-1","page":"Models and root manipulations","title":"Time domain","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"This package allows you to view a model through two different lenses: as a continuous-time model that models the differential properties of the signal, or as a discrete-time model that models the difference properties of the signal. Signals are inevetably sampled before the computer interacts with them, and are thus natively in the discrete domain. Theory, on the other hand, is slightly more intuitive in the continuous time domain. The two domains are related by the conformal mapping p_c = log(p_d) where p denotes a pole of a transfer function and subscripts cd denote the continuous and discrete domains respectively. When creating a distance, the default domain is Continuous. Some functions require you to be explicit regarding which domain you have in mind, such as when creating models from vectors or when asking for the roots/poles of a model.","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Sometimes you may get a message saying \"Roots on the negative real axis, no continuous time representation exist.\" when estimating a model from a signal. This means that one of the poles in the discrete time model, which is what is being estimated from data, landed on the legative real axis. No continuous-time system can ever create such a discrete-time model through sampling, and the some features of this package will work slightly worse if such a model is used, notably the EuclideanRootDistance and embedding. Optimal-transport based distances will not have a problem with this scenario.","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"To reduce the likelihood of this occurring, you may try to bandpass filter the signal before estimating the model, reduce the regularization factor if regularization was used, change the model order, or consider using the TLS fit method.","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"The difference between the pole locations in continuous and discrete time is vizualized in the pole diagrams below","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"pzmap(model, layout=2, sp=1, xlabel=\"Re\", ylabel=\"Im\", title=\"Continuous\")\nvline!([0], primary=false, l=(:black, :dash), sp=1)\npzmap!(tf(model,1),    sp=2, xlabel=\"Re\", ylabel=\"Im\", title=\"Discrete\")\nsavefig(\"pzmap_models2.html\"); nothing # hide","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"<object type=\"text/html\" data=\"../pzmap_models2.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"ltimodels/#Computational-performance-improvements-1","page":"Models and root manipulations","title":"Computational performance improvements","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Estimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by","category":"page"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Using Flaot32 instead of Float64\nUse MKL.jl instead of the default OpenBLAS (can yield about 2x performance improvement).","category":"page"},{"location":"ltimodels/#Type-reference-1","page":"Models and root manipulations","title":"Type reference","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Pages = [\"ltimodels.md\"]\nOrder   = [:type]","category":"page"},{"location":"ltimodels/#Function-reference-1","page":"Models and root manipulations","title":"Function reference","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Pages = [\"ltimodels.md\"]\nOrder   = [:function]","category":"page"},{"location":"ltimodels/#Docstrings-1","page":"Models and root manipulations","title":"Docstrings","text":"","category":"section"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"ltimodels.jl\",\"eigenvalue_manipulations.jl\"]","category":"page"},{"location":"ltimodels/#SpectralDistances.AR","page":"Models and root manipulations","title":"SpectralDistances.AR","text":"struct AR <: AbstractModel\n\nRepresents an all-pole transfer function, i.e., and AR model\n\nArguments:\n\na: denvec\nac: denvec cont. time\np: discrete time poles\npc: continuous time poles\nb: Numerator scalar\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.ARMA","page":"Models and root manipulations","title":"SpectralDistances.ARMA","text":"struct ARMA{T} <: AbstractModel\n\nRepresents an ARMA model, i.e., transfer function\n\nArguments:\n\nb: numvec\nbc: numvec cont. time\na: denvec\nac: denvec cont. time\nz: zeros\np: poles\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.AbstractModel","page":"Models and root manipulations","title":"SpectralDistances.AbstractModel","text":"abstract type AbstractModel <: ControlSystems.LTISystem end\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.FitMethod","page":"Models and root manipulations","title":"SpectralDistances.FitMethod","text":"Abstract type that represents a way to fit a model to data\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.IRLS","page":"Models and root manipulations","title":"SpectralDistances.IRLS","text":"IRLS <: FitMethod\n\nIteratively reqeighted least squares. This fitmethod is currently not recommended, it does not appear to produce nice spectra. (feel free to try it out though).\n\nArguments:\n\nna::Int: number of roots (order of the system)\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.LS","page":"Models and root manipulations","title":"SpectralDistances.LS","text":"LS <: FitMethod\n\nThis fitmethod is a good default option.\n\nArguments:\n\nna::Int: number of roots (order of the system). The number of peaks in the spectrum will be na÷2.\nλ::Float64 = 0.01: reg factor\n\nComputational performance improvements\n\nEstimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by\n\nUsing Flaot32 instead of Float64\nUse MKL.jl instead of the default OpenBLAS (can yield about 2x performance improvement).\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.PLR","page":"Models and root manipulations","title":"SpectralDistances.PLR","text":"PLR <: FitMethod\n\nPseudo linear regression. Estimates the noise components by performing an initial fit of higher order. Tihs fitmethod produces an ARMA model. Support for ARMA models is not as strong as for AR models.\n\nArguments:\n\nnc::Int: order of numerator\nna::Int: order of denomenator\ninitial::T = TLS(na=80): fitmethod for the initial fit. Can be, e.g., LS, TLS or any function that returns a coefficient vector\nλ::Float64 = 0.0001: reg factor\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.TLS","page":"Models and root manipulations","title":"SpectralDistances.TLS","text":"TLS <: FitMethod\n\nTotal least squares. This fit method is good if the spectrum has sharp peaks, in particular if the number of peaks is known in advance.\n\nArguments:\n\nna::Int: number of roots (order of the system). The number of peaks in the spectrum will be na÷2.\nλ::Float64 = 0: reg factor\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#PolynomialRoots.roots","page":"Models and root manipulations","title":"PolynomialRoots.roots","text":"roots(m::AbstractModel)\n\nReturns the roots of a model\n\n\n\n\n\n","category":"function"},{"location":"ltimodels/#SpectralDistances.checkroots-Tuple{DiscreteRoots}","page":"Models and root manipulations","title":"SpectralDistances.checkroots","text":"checkroots(r::DiscreteRoots) prints a warning if there are roots on the negative real axis.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.coefficients-Tuple{Discrete,AR}","page":"Models and root manipulations","title":"SpectralDistances.coefficients","text":"coefficients(::Domain, m::AbstractModel)\n\nReturn all fitted coefficients\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.examplemodels","page":"Models and root manipulations","title":"SpectralDistances.examplemodels","text":"examplemodels(n = 10)\n\nReturn n random models with 6 complex poles each.\n\n\n\n\n\n","category":"function"},{"location":"ltimodels/#SpectralDistances.fitmodel-Tuple{IRLS,AbstractArray}","page":"Models and root manipulations","title":"SpectralDistances.fitmodel","text":"fitmodel(fm::IRLS, X::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.fitmodel-Tuple{LS,AbstractArray}","page":"Models and root manipulations","title":"SpectralDistances.fitmodel","text":"fitmodel(fm::LS, X::AbstractArray)\n\nComputational performance improvements\n\nEstimating a lot (1000s) of models might take a while. The bulk of the time is spent performing a matrix factorization, something that can be significantly sped up by\n\nUsing Flaot32 instead of Float64\nUse MKL.jl instead of the default OpenBLAS (can yield about 2x performance improvement).\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.fitmodel-Tuple{PLR,AbstractArray}","page":"Models and root manipulations","title":"SpectralDistances.fitmodel","text":"fitmodel(fm::PLR, X::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.fitmodel-Tuple{TLS,AbstractArray}","page":"Models and root manipulations","title":"SpectralDistances.fitmodel","text":"fitmodel(fm::TLS, X::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.ls","page":"Models and root manipulations","title":"SpectralDistances.ls","text":"ls(A, y, λ=0)\n\nRegularized Least-squares\n\n\n\n\n\n","category":"function"},{"location":"ltimodels/#SpectralDistances.normalization_factor-Tuple{SpectralDistances.AbstractRoots}","page":"Models and root manipulations","title":"SpectralDistances.normalization_factor","text":"normalize_energy(r)\n\nReturns the factor that, when used to multiply the poles, results in a system with unit spectral energy.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.normalize_energy-Tuple{Any}","page":"Models and root manipulations","title":"SpectralDistances.normalize_energy","text":"normalize_energy(r)\n\nReturns poles scaled to achieve unit spectral energy.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.plr-NTuple{4,Any}","page":"Models and root manipulations","title":"SpectralDistances.plr","text":"plr(y, na, nc, initial; λ=0.01)\n\nPerforms pseudo-linear regression to estimate an ARMA model.\n\nArguments:\n\ny: signal\nna: denomenator order\nnc: numerator order\ninitial: fitmethod for the initial fit. Can be, e.g., LS, TLS or any function that returns a coefficient vector\nλ: reg\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.residues-Tuple{SpectralDistances.AbstractRoots}","page":"Models and root manipulations","title":"SpectralDistances.residues","text":"residues(r::AbstractRoots)\n\nReturns a vector of residues for the system represented by roots r\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.residues-Union{Tuple{CT}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,AbstractArray{CT,1}}} where CT","page":"Models and root manipulations","title":"SpectralDistances.residues","text":"residues(a::AbstractVector, b, r=roots(reverse(a)))\n\nReturns a vector of residues for the system represented by denominator polynomial a\n\nRef: slide 21 https://stanford.edu/~boyd/ee102/rational.pdf Tihs methid is numerically sensitive. Note that if two poles are on top of each other, the residue is infinite.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.roots2poly-Union{Tuple{AbstractArray{CT,1}}, Tuple{CT}} where CT","page":"Models and root manipulations","title":"SpectralDistances.roots2poly","text":"roots2poly(roots)\n\nAccepts a vector of complex roots and returns the polynomial with those roots\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.spectralenergy-Tuple{LTISystem}","page":"Models and root manipulations","title":"SpectralDistances.spectralenergy","text":"spectralenergy(G::LTISystem)\n\nCalculates the energy in the spectrum associated with G\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.spectralenergy-Union{Tuple{T}, Tuple{TimeDomain,AbstractArray{T,1},Any}} where T","page":"Models and root manipulations","title":"SpectralDistances.spectralenergy","text":"spectralenergy(d::TimeDomain, a::AbstractVector, b)\n\nCalculates the energy in the spectrum associated with transfer function b/a\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.Continuous","page":"Models and root manipulations","title":"SpectralDistances.Continuous","text":"Continuous time domain\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.ContinuousRoots","page":"Models and root manipulations","title":"SpectralDistances.ContinuousRoots","text":"ContinuousRoots{T, V <: AbstractVector{T}} <: AbstractRoots{T}\n\nRepresents roots in continuous time\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.ContinuousRoots-Tuple{DiscreteRoots}","page":"Models and root manipulations","title":"SpectralDistances.ContinuousRoots","text":"ContinuousRoots(r::DiscreteRoots) = begin\n\nRepresents roots of a polynomial in continuous time\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.Discrete","page":"Models and root manipulations","title":"SpectralDistances.Discrete","text":"Discrete (sampled) time domain\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.DiscreteRoots","page":"Models and root manipulations","title":"SpectralDistances.DiscreteRoots","text":"DiscreteRoots{T, V <: AbstractVector{T}} <: AbstractRoots{T}\n\nRepresent roots in discrete time\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.DiscreteRoots-Tuple{ContinuousRoots}","page":"Models and root manipulations","title":"SpectralDistances.DiscreteRoots","text":"DiscreteRoots(r::ContinuousRoots) = begin\n\nRepresents roots of a polynomial in discrete time\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.HungarianAssignement","page":"Models and root manipulations","title":"SpectralDistances.HungarianAssignement","text":"HungarianAssignement <: AbstractAssignmentMethod\n\nSort roots using Hungarian method\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.SortAssignement","page":"Models and root manipulations","title":"SpectralDistances.SortAssignement","text":"SortAssignement{F} <: AbstractAssignmentMethod\n\nContains a single Function field that determines what to sort roots by.\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.TimeDomain","page":"Models and root manipulations","title":"SpectralDistances.TimeDomain","text":"Abstract type that represents a time-domain, either Discrete or Continuous\n\n\n\n\n\n","category":"type"},{"location":"ltimodels/#SpectralDistances.change_precision-Tuple{Any,ContinuousRoots}","page":"Models and root manipulations","title":"SpectralDistances.change_precision","text":"change_precision(F, m::AbstractModel)\n\nChanges the precision of all fields in m to F, e.g., F=Float64. This can be useful since the default precision for many operations in this package is Double64. This ensures that roots are calculated with high accuracy, but the high precision might not be required to evaluate distances etc.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.domain_transform-Tuple{Discrete,ContinuousRoots}","page":"Models and root manipulations","title":"SpectralDistances.domain_transform","text":"domain_transform(d::Domain, e::AbstractRoots)\n\nChange the domain of the roots\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.hungariansort","page":"Models and root manipulations","title":"SpectralDistances.hungariansort","text":"hungariansort(p1, p2)\n\ntakes two vectors of numbers and sorts and returns p2 such that it is in the order of the best Hungarian assignement between p1 and p2. Uses abs for comparisons, works on complex numbers.\n\n\n\n\n\n","category":"function"},{"location":"ltimodels/#SpectralDistances.polar-Tuple{Number}","page":"Models and root manipulations","title":"SpectralDistances.polar","text":"polar(e::Number)\n\nmagnitude and angle of a complex number\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.reflect-Tuple{ContinuousRoots}","page":"Models and root manipulations","title":"SpectralDistances.reflect","text":"reflect(r::AbstractRoots)\n\nReflects unstable roots to a corresponding stable position (in unit circle for disc. in LHP for cont.)\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}","page":"Models and root manipulations","title":"SpectralDistances.residueweight","text":"residueweight(e::AbstractRoots)\n\nReturns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole. See also simplex_residueweight for a normalized version.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.simplex_residueweight-Tuple{Any}","page":"Models and root manipulations","title":"SpectralDistances.simplex_residueweight","text":"simplex_residueweight(x)\n\nReturns a vector where each entry is roughly corresponding to the amount of energy contributed to the spectrum be each pole, normalized to sum to 1. See residueweight for a non-normalized version.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#SpectralDistances.unitweight-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T","page":"Models and root manipulations","title":"SpectralDistances.unitweight","text":"unitweight(e)\n\nA weighting function that returns a vector of uniform weights that sum to 1.\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#","page":"Models and root manipulations","title":"Models and root manipulations","text":"ControlSystems.tf(m::AR, ts)\nControlSystems.tf(m::AR)\nControlSystems.denvec(::Discrete, m::SpectralDistances.AbstractModel)","category":"page"},{"location":"ltimodels/#ControlSystems.tf-Tuple{AR,Any}","page":"Models and root manipulations","title":"ControlSystems.tf","text":"ControlSystems.tf(m::AR, ts)\n\nConvert model to a transfer function compatible with ControlSystems.jl\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#ControlSystems.tf-Tuple{AR}","page":"Models and root manipulations","title":"ControlSystems.tf","text":"ControlSystems.tf(m::AR)\n\nConvert model to a transfer function compatible with ControlSystems.jl\n\n\n\n\n\n","category":"method"},{"location":"ltimodels/#ControlSystems.denvec-Tuple{Discrete,SpectralDistances.AbstractModel}","page":"Models and root manipulations","title":"ControlSystems.denvec","text":"ControlSystems.denvec(::TimeDomain, m::AbstractModel)\n\nGet the denominator polynomial vector\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"using SpectralDistances, Plots; plotly() # hide\nmodels = examplemodels(2)\nassignmentplot(models[1], models[2], d=Discrete(), p=2)\nsavefig(\"assignment.html\"); nothing # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"<object type=\"text/html\" data=\"../assignment.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"dist = OptimalTransportRootDistance(domain=Continuous())\nflowplot(dist, models...)\nsavefig(\"flowplot.html\"); nothing # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"<object type=\"text/html\" data=\"../flowplot.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Apart from the functions above, the plotting facilities from ControlSystems.jl should also work on models from this package, e.g., bodeplot, pzmap etc.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Pages = [\"plotting.md\"]\nOrder   = [:type, :function, :macro, :constant]","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Modules = [SpectralDistances]\nPrivate = false\nPages   = [\"plotting.jl\"]","category":"page"},{"location":"plotting/#SpectralDistances.assignmentplot","page":"Plotting","title":"SpectralDistances.assignmentplot","text":"assignmentplot(m1, m2)\n\nPlots the poles of two models and the optimal assignment between them\n\n\n\n\n\n","category":"function"},{"location":"plotting/#SpectralDistances.flowplot","page":"Plotting","title":"SpectralDistances.flowplot","text":"flowplot(dist,m1, m2)\n\nPlots the poles of two models and the optimal mass flow between them\n\n\n\n\n\n","category":"function"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"(Image: Build Status) (Image: codecov)","category":"page"},{"location":"#SpectralDistances-1","page":"SpectralDistances","title":"SpectralDistances","text":"","category":"section"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"This package facilitates the calculation of distances between signals, primarily in the frequency domain. The main functionality revolves around rational spectra, i.e., the spectrum of a rational function, known as a transfer function, an autoregressive model or an autoregressive moving-average model.","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"This repository implements all optimal-transport based distances between spectra detailed in the following pre-pre print","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"\"New Metrics Between Rational Spectra and their Connection to Optimal Transport\", Bagge Carlson and Chitre 2020","category":"page"},{"location":"#Installation-1","page":"SpectralDistances","title":"Installation","text":"","category":"section"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"The package is registered and you may install it by","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"using Pkg\npkg\"add SpectralDistances\"","category":"page"},{"location":"#High-level-overview-1","page":"SpectralDistances","title":"High-level overview","text":"","category":"section"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"The main workflow is as follows","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"Define a distance\nEvaluate the distance between two points (signals, histograms, periodograms, etc.)","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"You can also calculate barycenters, interpolations, and barycentric coordinates of signals under the chosen distance.","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"This package extends Distances.jl and all distance types are subtypes of Distances.PreMetric, even though some technically are true metrics and some are not even pre-metrics.","category":"page"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"Many distances are differentiable and can thus be used for gradient-based learning. The rest of this manual is divided into the following sections","category":"page"},{"location":"#Contents-1","page":"SpectralDistances","title":"Contents","text":"","category":"section"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"Pages = [\"distances.md\", \"time.md\", \"ltimodels.md\", \"interpolations.md\", \"plotting.md\", \"misc.md\", \"examples.md\"]","category":"page"},{"location":"#All-Exported-functions-and-types-1","page":"SpectralDistances","title":"All Exported functions and types","text":"","category":"section"},{"location":"#","page":"SpectralDistances","title":"SpectralDistances","text":"Pages = [\"distances.md\", \"time.md\", \"ltimodels.md\"]","category":"page"}]
}
