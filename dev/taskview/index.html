<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Task View · SpectralDistances</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralDistances</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Task View</a><ul class="internal"><li><a class="tocitem" href="#Classification"><span>Classification</span></a></li><li><a class="tocitem" href="#Detection"><span>Detection</span></a></li><li><a class="tocitem" href="#Unsupervised-learning"><span>Unsupervised learning</span></a></li><li><a class="tocitem" href="#Dimensionality-reduction"><span>Dimensionality reduction</span></a></li><li><a class="tocitem" href="#Dataset-augmentation"><span>Dataset augmentation</span></a></li><li><a class="tocitem" href="#Interpolation-between-spectra"><span>Interpolation between spectra</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Task View</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Task View</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/taskview.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Task-View"><a class="docs-heading-anchor" href="#Task-View">Task View</a><a id="Task-View-1"></a><a class="docs-heading-anchor-permalink" href="#Task-View" title="Permalink"></a></h1><p>This page breaks functionality up according to tasks in order to make it easier to find relevant functions. Throughout this page, we assume that you are familiar with how to estimate models (<a href="../ltimodels/#Models-and-root-manipulations">Models and root manipulations</a>) and specify distances (<a href="../distances/#Distances">Distances</a>).</p><h2 id="Classification"><a class="docs-heading-anchor" href="#Classification">Classification</a><a id="Classification-1"></a><a class="docs-heading-anchor-permalink" href="#Classification" title="Permalink"></a></h2><p>There are two main ways to perform classification using the functionality in this package</p><ul><li>Nearest-neighbor based</li><li>Feature based</li></ul><h3 id="Nearest-neighbor-based-classification"><a class="docs-heading-anchor" href="#Nearest-neighbor-based-classification">Nearest-neighbor based classification</a><a id="Nearest-neighbor-based-classification-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-neighbor-based-classification" title="Permalink"></a></h3><p>This is very simple, select a distance, and calculate the nearest neighbor from a dataset to your query. The dataset can be either a vector of models estimated from signals, a vector of spectrograms, or a matrix of embedding vectors derived from models.</p><p>First, we demonstrate how one can perform &quot;leave-one-out&quot; corss validation within a labeled dataset, i.e., for each example, classify it using all the others. Since a distance based classifier does not have an explicit &quot;training phase&quot;, this sort of cross-validation is comparatively cheap to perform.</p><p>Any distance can be used to calculate a distance matrix using the function <a href="../distances/#SpectralDistances.distmat-Tuple{Any, AbstractVector}"><code>distmat</code></a>. Given a distance matrix <code>D</code>, you can predict the nearest-neighbor class with the following function</p><pre><code class="language-julia hljs">function predict_nn(labels::Vector{Int}, D)
    dists, inds = findmin(D + Inf*I, dims=2) # The diagonal contains trivial matches, hence add infinite Identity
    inds = vec(getindex.(inds, 2))
    map(i-&gt;labels[i], inds)
end

predicted_classes = predict_nn(labels, D)</code></pre><p>When we want to <em>classify a new sample</em> <code>q</code>, we can simply broadcast<sup class="footnote-reference"><a id="citeref-tmap" href="#footnote-tmap">[tmap]</a></sup> a distance <code>d</code> between <code>q</code> and all labeled samples in the training set</p><pre><code class="language-julia hljs">dists = d.(models_train, q)
predicted_class = labels[argmin(dists)]</code></pre><p>note that if you&#39;re doing <em>detection</em>, i.e., looking for a short <code>q</code> in a much longer time series, see <a href="#Detection">Detection</a> below, and the function <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{&lt;:OptimalTransportRootDistance}, TimeVaryingAR, TimeVaryingAR}"><code>distance_profile</code></a>.</p><h4 id="Nearest-neighbor-using-embeddings"><a class="docs-heading-anchor" href="#Nearest-neighbor-using-embeddings">Nearest neighbor using embeddings</a><a id="Nearest-neighbor-using-embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-neighbor-using-embeddings" title="Permalink"></a></h4><p>By far the fastest neighbor querys can be made by extracting embeddings from estimated models and using a KD-tree to accelerate neigbor searches. Below, we&#39;ll go into detail on how to do this. This corresponds to using the <a href="../distances/#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> with uniform weighting on the poles.</p><p>The following function finds you the <span>$k$</span> most likely classes corresponding to query embedding <code>q</code> from within <code>Xtrain</code>. <code>Xtrain</code> and <code>q</code> are expected to be embeddings formed by the function <a href="https://github.com/baggepinnen/AudioClustering.jl#estimating-linear-models"><code>embeddings</code></a> from <a href="https://github.com/baggepinnen/AudioClustering.jl">AudioClustering.jl</a>. (See <a href="../examples/#Calculate-root-embeddings-from-sound-files">Calculate root embeddings from sound files</a> for an intro.)</p><pre><code class="language-julia hljs">using MultivariateStats, NearestNeighbors, AudioClustering

Xtrain = embeddings(models_train) # Assumes that you have already estimated models

function knn_classify(labels, Xtrain, q, k)
    N = size(Xtrain,2)
    W = fit(Whitening, Xtrain)
    X = MultivariateStats.transform(W,Xtrain)
    q = MultivariateStats.transform(W,q)
    tree = NearestNeighbors.KDTree(Xtrain)
    inds, dists = knn(tree, q, min(5k+1, N-1), true)
    ul = unique(labels[inds[2:end]])
    ul[1:min(k, length(ul))]
end</code></pre><p>Increased accuracy is often obtained by estimating models with a few different specifications and fitting methods and use them all to form predictions (this will form an ensemble). The following code fits models with different fit methods and of different orders</p><pre><code class="language-julia hljs">using ThreadTools, AudioClustering, ProgressMeter
modelspecs = collect(Iterators.product(10:2:14, (TLS,LS))) # Model order × fitmethod

manymodels = @showprogress &quot;Estimating models&quot; map(modelspecs) do (na, fm)
    fitmethod = fm(na=na, λ=1e-5)
    tmap(sounds) do sound
        sound = @view(sound[findfirst(!iszero, sound):findlast(!iszero, sound)])
        sound = Float32.(SpectralDistances.bp_filter(sound, (50 / fs, 0.49))) # Apply some bandpass filtering
        fitmethod(sound)
    end
end

manyX = embeddings.(manymodels) # This is not a matrix of matrices</code></pre><p>To predict a single class, let many classifiers vote for the best class</p><pre><code class="language-julia hljs">using MLBase # For mode

function vote(preds)
    map(1:length(preds[1])) do i
        mode(getindex.(preds, i))
    end
end

votes = [classpred1, classpred2, classpred3, ...] # Each classpred can be obtained by, e.g., knn_classify above.
majority_vote = vote(votes)
@show mean(labels .== majority_vote) # Accuracy</code></pre><p>To predict &quot;up to <span>$k$</span> classes&quot;, try the following</p><pre><code class="language-julia hljs">using StatsBase # for countmap
function predict_k(labels, preds, k)
    map(eachindex(labels)) do i
        cm = countmap(getindex.(preds, i)) |&gt; collect |&gt; x-&gt;sort(x, by=last, rev=true)
        first.(cm[1:min(k,length(cm))])
    end
end

votes = [classpred1, classpred2, classpred3, ...]
k_votes = predict_k(labels, votes, k)
@show mean(labels .∈ k_votes) # Accuracy</code></pre><p>To figure out which classifier is best, rank them like so</p><pre><code class="language-julia hljs">function ranking(labels, preds)
    scores = [mean(labels .== yh) for yh in preds]
    sortperm(scores, rev=true)
end

votes = [classpred1, classpred2, classpred3, ...]
r = ranking(labels, votes)</code></pre><h3 id="Feature-based-classification"><a class="docs-heading-anchor" href="#Feature-based-classification">Feature-based classification</a><a id="Feature-based-classification-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-based-classification" title="Permalink"></a></h3><p>The embeddings extracted above can be used as features for a standard classifier. Below we show an example using a random forest</p><pre><code class="language-julia hljs">using DecisionTree, MultivariateStats, Random, AudioClustering
N       = length(labels)
X       = embeddings(models)&#39; |&gt; copy # DecisionTree expects features along columns
perm    = randperm(N)
Nt      = N ÷ 2 # Use half dataset for training
train_x = X[perm[1:Nt], :]
train_y = labels[perm[1:Nt]]
test_x  = X[perm[Nt+1:end], :]
test_y  = labels[perm[Nt+1:end]]

model = RandomForestClassifier(n_trees=400, max_depth=15)
DecisionTree.fit!(model, train_x, train_y)

predictions = DecisionTree.predict(model, test_x)
k_predictions =
getindex.(sortperm.(eachrow(predict_proba(model, test_x)), rev = true), Ref(1:3)) # Predict top 3
@show accuracy = mean(predictions .== test_y)    # Top class prediction accuracy
@show accuracy = mean(test_y .∈ k_predictions)  # Top 3 classes predictions accuracy</code></pre><p>The features derived here can of course be combined with any number of other features, such as from <a href="https://github.com/ymtoo/AcousticFeatures.jl/">AcousticFeatures.jl</a>.</p><h2 id="Detection"><a class="docs-heading-anchor" href="#Detection">Detection</a><a id="Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Detection" title="Permalink"></a></h2><p>Detection refers to finding a short query pattern <code>q</code> in a long recording <code>y</code>. This task can often be performance optimized for expensive-to-compute distances.</p><p>In its most basic form, a dection score can be calculated by simply broadcasting a distance over <code>y</code>, see <a href="../examples/#Detection-using-examples">Detection using examples</a>.</p><p>For spectrogram distances, we have optimized methods for calculating distance profiles, see <a href="../examples/#Computing-a-spectrogram-distance-profile">Computing a spectrogram distance profile</a>. Also <a href="../time/#SpectralDistances.TimeDistance"><code>TimeDistance</code></a> has an optimized method for <a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{&lt;:OptimalTransportRootDistance}, TimeVaryingAR, TimeVaryingAR}"><code>distance_profile</code></a>.</p><p>Detection can also be done using Dynamic Time Warping combined with optimal transport, see <a href="../time/#Dynamic-Time-Warping">Dynamic Time Warping</a>. For examples of the combination of DTW and OT, see the following notebooks</p><ul><li><a href="https://nbviewer.jupyter.org/github/baggepinnen/julia_examples/blob/master/frequency_warping.ipynb">DTW-OT: Introduction</a></li><li><a href="https://nbviewer.jupyter.org/github/baggepinnen/julia_examples/blob/master/frequency_warping2.ipynb">DTW-OT: Detection</a></li></ul><h2 id="Unsupervised-learning"><a class="docs-heading-anchor" href="#Unsupervised-learning">Unsupervised learning</a><a id="Unsupervised-learning-1"></a><a class="docs-heading-anchor-permalink" href="#Unsupervised-learning" title="Permalink"></a></h2><p>For clustering applications, there are a number of approaches</p><ul><li>Distance matrix</li><li>Feature-based</li><li>K-barycenters</li></ul><h3 id="Clustering-using-a-distance-matrix"><a class="docs-heading-anchor" href="#Clustering-using-a-distance-matrix">Clustering using a distance matrix</a><a id="Clustering-using-a-distance-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-using-a-distance-matrix" title="Permalink"></a></h3><p>Using <a href="../distances/#SpectralDistances.distmat-Tuple{Any, AbstractVector}"><code>distmat</code></a> with keyword arg <code>normalize=true</code>, you can obtain a distance matrix that can be used with a large number of clustering algorithms from <a href="https://juliastats.org/Clustering.jl/stable/index.html">Clustering.jl</a> or <a href="https://github.com/baggepinnen/HDBSCAN.jl">HDBSCAN.jl</a>.</p><h3 id="Clustering-using-features"><a class="docs-heading-anchor" href="#Clustering-using-features">Clustering using features</a><a id="Clustering-using-features-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-using-features" title="Permalink"></a></h3><p>Using <a href="https://github.com/baggepinnen/AudioClustering.jl#estimating-linear-models"><code>embeddings</code></a> from AudioClustering.jl, you can run regular K-means which is blazingly fast, but often produces worse clusterings than more sophisticated methods.</p><h3 id="Clustering-using-K-barycenters"><a class="docs-heading-anchor" href="#Clustering-using-K-barycenters">Clustering using K-barycenters</a><a id="Clustering-using-K-barycenters-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-using-K-barycenters" title="Permalink"></a></h3><p>This approach is similar to K-means, but uses a transport-based method to calculate distances and form averages rather than the Euclidean distance. See the example <a href="../interpolations/#K-Barycenters">K-Barycenters</a>.</p><h3 id="Finding-motifs-or-outliers"><a class="docs-heading-anchor" href="#Finding-motifs-or-outliers">Finding motifs or outliers</a><a id="Finding-motifs-or-outliers-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-motifs-or-outliers" title="Permalink"></a></h3><p>To find motifs (recurring patterns) or outliers (discords), see <a href="https://github.com/baggepinnen/MatrixProfile.jl">MatrixProfile.jl</a> which interacts well with SpectralDistances.jl.</p><h2 id="Dimensionality-reduction"><a class="docs-heading-anchor" href="#Dimensionality-reduction">Dimensionality reduction</a><a id="Dimensionality-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensionality-reduction" title="Permalink"></a></h2><p>Several sounds from the same class can be reduced to a smaller number of sounds by forming a barycenter. See examples <a href="../interpolations/#Barycenters">Barycenters</a>, <a href="../interpolations/#Barycenters-between-spectrograms">Barycenters between spectrograms</a> and the figure in the <a href="https://github.com/baggepinnen/SpectralDistances.jl">readme</a> (reproduced below) which shows how four spectrograms can be used to calculate a &quot;center spectrogram&quot;.</p><p><img src="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/examples/barycenters.png?raw=true" alt="window"/></p><h2 id="Dataset-augmentation"><a class="docs-heading-anchor" href="#Dataset-augmentation">Dataset augmentation</a><a id="Dataset-augmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-augmentation" title="Permalink"></a></h2><p>Barycenters can also be used also to augment datasets with points &quot;in-between&quot; other points. The same figure in the <a href="https://github.com/baggepinnen/SpectralDistances.jl">readme</a> (reproduced above) illustrates how four spectrogams are extended into 25 spectrograms.</p><h2 id="Interpolation-between-spectra"><a class="docs-heading-anchor" href="#Interpolation-between-spectra">Interpolation between spectra</a><a id="Interpolation-between-spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-between-spectra" title="Permalink"></a></h2><p>An interpolation between spectra is obtained by calculating a <a href="../interpolations/#SpectralDistances.barycenter"><code>barycenter</code></a> using varying barycentric coordinates. See <a href="../interpolations/#Interpolations-and-Barycenters">Interpolations and Barycenters</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-tmap"><a class="tag is-link" href="#citeref-tmap">tmap</a>If <code>d</code> is an expensive distance to compute, you may want to consider using <code>tmap</code> from <a href="https://github.com/baggepinnen/ThreadTools.jl instead. If you do, make sure you copy the distance object to each thread, in case it contains an internal cache.">ThreadTools.jl</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 4 July 2025 05:07">Friday 4 July 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
