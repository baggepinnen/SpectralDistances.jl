<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distances · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li class="is-active"><a class="tocitem" href>Distances</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#A-full-example-1"><span>A full example</span></a></li><li><a class="tocitem" href="#Using-Welch-periodograms-1"><span>Using Welch periodograms</span></a></li><li><a class="tocitem" href="#Gradients-1"><span>Gradients</span></a></li><li><a class="tocitem" href="#Unbalanced-transport-1"><span>Unbalanced transport</span></a></li><li><a class="tocitem" href="#Function-reference-1"><span>Function reference</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li><li><a class="tocitem" href="#Details-1"><span>Details</span></a></li></ul></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distances</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distances</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/distances.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Distances-1"><a class="docs-heading-anchor" href="#Distances-1">Distances</a><a class="docs-heading-anchor-permalink" href="#Distances-1" title="Permalink"></a></h1><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>The following is a reference for all the distances defined in this package. Once a distance object is defined, it can be evaluated in one of two ways, defined by the  <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> interface</p><pre><code class="language-julia">dist = DistanceType(options)
d = evaluate(d, x1, x2; kwargs...) # keyword arguments are used to control the solvers for some transport-based distances
d = dist(x1, x2) # A shorter syntax for calling the distance</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All distances return the distance raised to the power <code>p</code>, thus <code>RationalOptimalTransportDistance(p=2)(x1,x2)</code> <span>$= W_2(x_1,x_2)^2$</span> where <span>$W_2$</span> denotes the Wasserstein distance of order 2.</p></div></div><p>Before we proceed, we list a number of classes of distances that are available</p><ul><li><a href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a></li><li><a href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a></li><li><a href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a></li><li><a href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a></li><li><a href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a></li><li><a href="#SpectralDistances.ConvOptimalTransportDistance"><code>SpectralDistances.ConvOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.DiscreteGridTransportDistance-Tuple{Distances.PreMetric,Any,Any,Any}"><code>SpectralDistances.DiscreteGridTransportDistance</code></a></li><li><a href="#SpectralDistances.DiscreteGridTransportDistance"><code>SpectralDistances.DiscreteGridTransportDistance</code></a></li><li><a href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a></li><li><a href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a></li><li><a href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a></li><li><a href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a></li><li><a href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a></li><li><a href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportRootDistance"><code>SpectralDistances.OptimalTransportRootDistance</code></a></li><li><a href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a></li><li><a href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.SCWorkspace-Tuple{Any,Any,Any}"><code>SpectralDistances.SCWorkspace</code></a></li><li><a href="#SpectralDistances.SlidingConvOptimalTransportDistance"><code>SpectralDistances.SlidingConvOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.SymmetricDistance"><code>SpectralDistances.SymmetricDistance</code></a></li><li><a href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a></li><li><a href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a></li></ul><p>Some of these distances operate directly on signals, these are</p><pre><code class="language-none">EnergyDistance
ModelDistance
SpectralDistances.AbstractWelchDistance</code></pre><p>Of these, <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> is a bit special, works like this</p><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ModelDistance" href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelDistance{D &lt;: AbstractDistance} &lt;: AbstractSignalDistance</code></pre><p>A model distance operates on signals and works by fitting an LTI model to the signals before calculating the distance. The distance between the LTI models is defined by the field <code>distance</code>. This is essentially a wrapper around the inner distance that handles the fitting of a model to the signals. How the model is fit is determined by <code>fitmethod</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>fitmethod::</code><a href="../ltimodels/#SpectralDistances.FitMethod"><code>FitMethod</code></a>: <a href="../ltimodels/#SpectralDistances.LS"><code>LS</code></a>, <a href="../ltimodels/#SpectralDistances.TLS"><code>TLS</code></a> or <a href="../ltimodels/#SpectralDistances.PLR"><code>PLR</code></a></li><li><code>distance::D</code>: The inner distance between the models</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances
innerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)
dist = ModelDistance(TLS(na=30), innerdistance)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L65-L80">source</a></section></article><p>The inner distance in <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> can be any <a href="#SpectralDistances.AbstractRationalDistance"><code>AbstractRationalDistance</code></a>. The options are</p><pre><code class="language-none">DiscretizedRationalDistance
RationalCramerDistance
RationalOptimalTransportDistance
SpectralDistances.AbstractCoefficientDistance
SpectralDistances.AbstractRootDistance</code></pre><p>These distances operate on LTI models. Some operate on the coefficients of the models</p><pre><code class="language-none">CoefficientDistance</code></pre><p>and some operate on the roots of the models</p><pre><code class="language-none">EuclideanRootDistance
HungarianRootDistance
KernelWassersteinRootDistance
OptimalTransportRootDistance</code></pre><h2 id="A-full-example-1"><a class="docs-heading-anchor" href="#A-full-example-1">A full example</a><a class="docs-heading-anchor-permalink" href="#A-full-example-1" title="Permalink"></a></h2><p>To use the <a href="#SpectralDistances.OptimalTransportRootDistance"><code>OptimalTransportRootDistance</code></a> and let it operate on signals, we may construct our distance object as follows</p><pre><code class="language-julia-repl">julia&gt; innerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)
OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.005, 2, nothing)

julia&gt; dist = ModelDistance(TLS(na=10), innerdistance)
ModelDistance{OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing},TLS}(TLS(10, 0.0), OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.005, 2, nothing))

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
1.2729588491593158

julia&gt; dist = ModelDistance(LS(na=2), innerdistance);

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
0.0005678342162688199

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.004073228552285849</code></pre><h2 id="Using-Welch-periodograms-1"><a class="docs-heading-anchor" href="#Using-Welch-periodograms-1">Using Welch periodograms</a><a class="docs-heading-anchor-permalink" href="#Using-Welch-periodograms-1" title="Permalink"></a></h2><p>We can calculate the Wasserstein distance between spectra estimated using the Welch method like so</p><pre><code class="language-julia-repl">julia&gt; dist = WelchOptimalTransportDistance(p=2)
WelchOptimalTransportDistance{Nothing,Tuple{},NamedTuple{(),Tuple{}}}(nothing, (), NamedTuple(), 2)

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
0.0001767497377532134

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
0.00035863696706223353

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.0011840976205946979</code></pre><h2 id="Gradients-1"><a class="docs-heading-anchor" href="#Gradients-1">Gradients</a><a class="docs-heading-anchor-permalink" href="#Gradients-1" title="Permalink"></a></h2><p>Some distances will allow you to propagate gradients through them. Below is an example using Zygote and the <a href="#SpectralDistances.OptimalTransportRootDistance"><code>OptimalTransportRootDistance</code></a></p><pre><code class="language-julia">using Zygote
Zygote.@nograd rand # Currently needed woraround
x1 = SpectralDistances.bp_filter(randn(100000), (0.1,0.3))  # Create two signals
x2 = SpectralDistances.bp_filter(randn(100000), (0.1,0.2))
fm = LS(na=10)      # LS is the best supported fitmethod for gradients

dist = ModelDistance(fm,OptimalTransportRootDistance(domain = Continuous()))      # Since we&#39;re measureing distance between signals, we wrap the distance in a ModelDistance</code></pre><pre><code class="language-none">ModelDistance{OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing},LS}(LS(10, 0.01), OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.01, 2, nothing))</code></pre><pre><code class="language-julia-repl">julia&gt; dist(x1,x2)
0.027920011115114142

julia&gt; ∇x1 = Zygote.gradient(x-&gt;real(evaluate(dist,x,x2)), x1)[1] # The call to real is a workaround for a Zygote bug
100000-element Array{Float64,1}:
 -1.932770859869181e-6
  2.382016720278893e-6
  2.2543149003859472e-7
 -8.475811075292392e-7
  3.9093908365257944e-6
 -4.004227912794681e-6
  5.360684130931162e-6
 -6.10894343642722e-6
  8.509317487618465e-6
 -4.90756985564268e-6
  ⋮
  1.863018926598971e-6
 -1.5430406528811455e-6
  1.023387661975822e-6
  4.890422799423483e-7
  7.604879131906284e-7
  4.409115215646344e-6
 -1.6064459303721756e-6
  2.768099321955727e-6
 -9.39675960445359e-7</code></pre><p>The differentiation takes some time, but it should be fast enough to be generally useful for gradient-based learning of autoencoders etc. The following is a benchmark performed on an old laptop without GPU (the distances are not yet tested on GPUs)</p><pre><code class="language-julia">@btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$x2)), $x1);
#  134.965 ms (107566 allocations: 134.77 MiB)</code></pre><p>with a precomputed reference model, it goes even faster</p><pre><code class="language-julia">m2 = fm(x2)
m2 = change_precision(Float64, m2) # Tihs step is important for performance
@btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$m2)), $x1);
#  80.200 ms (103437 allocations: 69.62 MiB)</code></pre><p>The same benchmarks performed on a 2019 desktop computer yields the following timings</p><pre><code class="language-julia">julia&gt; @btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$x2)), $x1);
  45.926 ms (107748 allocations: 136.18 MiB)

julia&gt; @btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$m2)), $x1);
  25.120 ms (103619 allocations: 71.03 MiB)</code></pre><h2 id="Unbalanced-transport-1"><a class="docs-heading-anchor" href="#Unbalanced-transport-1">Unbalanced transport</a><a class="docs-heading-anchor-permalink" href="#Unbalanced-transport-1" title="Permalink"></a></h2><p>There are situations in which one would like to avoid fully transporting all mass between two measures. A few such cases are</p><ul><li>The two measures do not have the same mass. In this case, the standard, balanced, optimal-transport problem is unfeasible.</li><li>Energy is somehow lost or added to one spectra in a way that should not be accounted for by transport. This would be the case if<ul><li>Spectral energy is absorbed by a channel through which a signal is propagated. In this case it would not make sense to try to transport mass from the other spectrum away from the absorbed (dampended) frequency.</li><li>Spectral energy is added by a noise source. This energy should ideally not be considered for transport and should rather be destroyed.</li></ul></li></ul><p>For situations like this, an <code>AbstractDivergence</code> can be supplied to the <code>OptimalTransportRootDistance</code>. This divergence specifies how expensive it is to create or destroy mass in the spectra. The available divergences are listed in <a href="https://ericphanson.github.io/UnbalancedOptimalTransport.jl/stable/public_api/#Divergences-1">the docs of UnbalancedOptimalTransport.jl</a>, to which we outsource the solving of the unbalanced problem. For convenience, the wrapper <a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>sinkhorn_unbalanced</code></a> is available to interface the unbalanced solver in the same way as the solvers from this package are interfaced.</p><pre><code class="language-julia-repl">julia&gt; using DSP

julia&gt; fm = LS(na = 10);

julia&gt; m1 = fm(filtfilt(ones(10), [10], randn(1000)));
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists. Consider prefiltering the signal or decreasing the regularization factor.
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/ltimodels.jl:83

julia&gt; m2 = fm(filtfilt(ones(5), [5], randn(1000)));
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists. Consider prefiltering the signal or decreasing the regularization factor.
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/ltimodels.jl:83

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=Balanced())
OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Balanced}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.01, 1, Balanced())

julia&gt; d1 = evaluate(dist,m1,m2)
0.09408422685515523

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(1.0));

julia&gt; d2 = evaluate(dist,m1,m2)
0.08900897776838497

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(10.0));

julia&gt; d3 = evaluate(dist,m1,m2)
0.09354791086146051

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(0.01));

julia&gt; d4 = evaluate(dist,m1,m2)
0.02519920057813581

julia&gt; d1 &gt; d3 &gt; d2 &gt; d4
true</code></pre><p>When the distance is evaluated the second time, unbalanced transport is used. The <code>d2</code> should be equal to or smaller than <code>d1</code>. If we make the <code>KL</code> term larger, the distance approaches the balanced cost, and if we make it smaller, it becomes very cheap to create/destroy mass and less mass is transported.</p><p>The first case, where <code>divergence=Balanced()</code> was supplied, should be equivalent to not providing any divergence at all. In pratice results might differ slightly since a different solver implementation is used.</p><p>Below is an example in which the unbalanced transport between two systems is computed. The two systems do not have the same number of poles, and if destruction of mass is made cheap, not all mass is transported. The thickness of the lines indicate mass flow.</p><pre><code class="language-julia">using Plots
m1 = AR(Continuous(), [1, 0.1, 1.3])                        |&gt; change_precision(Float64)
m2 = AR(Continuous(), polyconv([1, 0.1, 1], [1, 0.1, 1.2])) |&gt; change_precision(Float64)
D  = SpectralDistances.distmat_euclidean(m1.pc, m2.pc)
w1, w2 = unitweight.((m1, m2))
figs = map([0.001, 0.01, 0.1]) do tv
    divergence = TV(tv)
    Γ, a, b = sinkhorn_unbalanced(D, w1, w2, divergence, β = 0.01)
    lineS   = 20Γ
    lineS[lineS.&lt;0.1] .= 0
    alphaS  = lineS ./ maximum(lineS)
    f       = scatter(m1.pc, legend = false, ms = 10, title = &quot;TV=$tv&quot;)
    scatter!(m2.pc, ms = 10)
    for (i, p1) in enumerate(m1.pc), (j, p2) in enumerate(m2.pc)
        coords = [p1, p2]
        plot!(
            real(coords),
            imag(coords),
            linewidth = lineS[i, j],
            alpha     = alphaS[i, j],
            color     = :black,
        )
    end
    f
end
plot(figs..., layout = (1, 3), ylims = (0.9, 1.2))</code></pre><pre><code class="language-none">┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/nCtbM/src/ticks.jl:283</code></pre><object type="text/html" data="../unbalanced_poles.html" style="width:100%;height:450px;"></object><h2 id="Function-reference-1"><a class="docs-heading-anchor" href="#Function-reference-1">Function reference</a><a class="docs-heading-anchor-permalink" href="#Function-reference-1" title="Permalink"></a></h2><ul><li><a href="#SpectralDistances.IPOT"><code>SpectralDistances.IPOT</code></a></li><li><a href="#SpectralDistances.discrete_grid_transportcost-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any,Any}} where T"><code>SpectralDistances.discrete_grid_transportcost</code></a></li><li><a href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a></li><li><a href="#SpectralDistances.distmat-Tuple{Any,AbstractArray{T,1} where T}"><code>SpectralDistances.distmat</code></a></li><li><a href="#SpectralDistances.distmat_euclidean"><code>SpectralDistances.distmat_euclidean</code></a></li><li><a href="#SpectralDistances.distmat_euclidean!"><code>SpectralDistances.distmat_euclidean!</code></a></li><li><a href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.mask_filter"><code>SpectralDistances.mask_filter</code></a></li><li><a href="#SpectralDistances.normalize_spectrogram-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T"><code>SpectralDistances.normalize_spectrogram</code></a></li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a></li><li><a href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a></li><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a></li><li><a href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>SpectralDistances.sinkhorn_convolutional</code></a></li><li><a href="#SpectralDistances.sinkhorn_convolutional-Union{Tuple{T}, Tuple{SCWorkspace{T},AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where T"><code>SpectralDistances.sinkhorn_convolutional</code></a></li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a></li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a></li><li><a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>SpectralDistances.sinkhorn_unbalanced</code></a></li></ul><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractDistance" href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The top level distance type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractRationalDistance" href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on rational transfer functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractSignalDistance" href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on signals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.BuresDistance" href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuresDistance &lt;: AbstractDistance</code></pre><p>Distance between pos.def. matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L303-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.CoefficientDistance" href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoefficientDistance{D, ID} &lt;: AbstractCoefficientDistance</code></pre><p>Distance metric based on model coefficients</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance between coeffs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L50-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteGridTransportDistance" href="#SpectralDistances.DiscreteGridTransportDistance"><code>SpectralDistances.DiscreteGridTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteGridTransportDistance{DT} &lt;: AbstractDistance</code></pre><p>Optimal transport between two measures on a common discrete grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscreteGridTransportDistance-Tuple{Distances.PreMetric,Any,Any,Any}" href="#SpectralDistances.DiscreteGridTransportDistance-Tuple{Distances.PreMetric,Any,Any,Any}"><code>SpectralDistances.DiscreteGridTransportDistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteGridTransportDistance(Cityblock(), Float32, n, n)</code></pre><p>The constructor takes an inner distance, the numeric type and the length of the two measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscretizedRationalDistance" href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscretizedRationalDistance{WT, DT} &lt;: AbstractRationalDistance</code></pre><p>This distance discretizes the spectrum before performing the calculations.</p><p><strong>Arguments:</strong></p><ul><li><code>w::WT = LinRange(0.01, 0.5, 300)</code>: Frequency set</li><li><code>distmat::DT = distmat_euclidean(w, w)</code>: DESCRIPTION</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EnergyDistance" href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EnergyDistance &lt;: AbstractSignalDistance</code></pre><p><code>std(x1) - std(x2)</code> This distance can be added to a loss function to ensure that the energy in the two signals is the same. Some of the optimal transport-based distances are invariant to the energy in the signal, requiring this extra cost if that invariance is not desired. Combining distances is done by putting two or more in a tuple.     Usage: <code>combined_loss = (primary_distance, EnergyDistance())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L311-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EuclideanRootDistance" href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EuclideanRootDistance{D, A, F1, F2} &lt;: AbstractRootDistance</code></pre><p>Simple euclidean distance between roots of transfer functions</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>assignment::A =</code> <a href="../ltimodels/#SpectralDistances.SortAssignement"><code>SortAssignement</code></a><code>(imag)</code>: Determines how roots are assigned. An alternative is <code>HungarianAssignement</code></li><li><code>transform::F1 = identity</code>: DESCRIPTION</li><li><code>weight</code> : A function used to calculate weights for the induvidual root distances. A good option is <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a></li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.HungarianRootDistance" href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HungarianRootDistance{D, ID &lt;: Distances.PreMetric, F} &lt;: AbstractRootDistance</code></pre><p>Similar to <a href="#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> but does the pole assignment using the Hungarian method.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D = Continuous()</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.KernelWassersteinRootDistance" href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KernelWassersteinRootDistance{D, F, DI} &lt;: AbstractRootDistance</code></pre><p>A kernel version of the root distance</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D = Continuous()</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>λ::Float64 = 1.0</code>: Kernel precision, lower value means wider kernel.</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.OptimalTransportHistogramDistance" href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimalTransportHistogramDistance{DT} &lt;: AbstractDistance</code></pre><p>Optimal transport between two histograms. If you pass two vectors to this distance two histograms will be computed automatically (<code>fit(Histogram,x)</code>). Pass two histograms to get better manual control.</p><p><strong>Arguments:</strong></p><ul><li><code>p::Int = 1</code>: order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.OptimalTransportRootDistance" href="#SpectralDistances.OptimalTransportRootDistance"><code>SpectralDistances.OptimalTransportRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimalTransportRootDistance{D, F1, F2, S} &lt;: AbstractRootDistance</code></pre><p>The Sinkhorn distance between roots. The weights are provided by <code>weight</code>, which defaults to <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D = Continuous()</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>transform::F1 = identity</code>: Probably not needed.</li><li><code>weight::F2 =</code><a href="../ltimodels/#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>simplex_residueweight</code></a>: A function used to calculate weights for the induvidual root distances.</li><li><code>β::Float64 = 0.01</code>: Amount of entropy regularization</li><li><code>p::Int = 2</code> : Order of the distance</li><li><code>divergence::S = nothing</code>: A divergence that penalizes creation and destruction of mass.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalCramerDistance" href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RationalCramerDistance{DT} &lt;: AbstractRationalDistance</code></pre><p>Similar to <code>RationalOptimalTransportDistance</code> but does not use inverse functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT = Continuous()</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 2</code>: order</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L286-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalOptimalTransportDistance" href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CationalOptimalTransportDistance{DT, MT} &lt;: AbstractRationalDistanCe</code></pre><p>calculates the Wasserstein distance using the closed-form sold*c for (d,c) in zip(D,C)s and inverse cumulative functions.</p><p>C ArgumentC:</p><ul><li><code>domain::DT = Continuous()</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or [<code>Continuous</code>](@red*c for (d,c) in zip(D,C)r</li><li><code>magnitude::MT = Identity()</code>:</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L267-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SymmetricDistance" href="#SpectralDistances.SymmetricDistance"><code>SpectralDistances.SymmetricDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SymmetricDistance{D} &lt;: AbstractDistance</code></pre><p>Evaluates <code>d(x,y) - 0.5(d(x,x) + d(y,y))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchLPDistance" href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchLPDistance{AT &lt;: Tuple, KWT &lt;: NamedTuple, F} &lt;: AbstractWelchDistance</code></pre><p>Lᵖ distance between welch spectra, <code>mean(abs(x1-x2)^p)</code>.</p><p>#Arguments:</p><ul><li><code>args::AT = ()</code>: These are sent to <code>welch_pgram</code></li><li><code>kwargs::KWT = NamedTuple()</code>: These are sent to <code>welch_pgram</code></li><li><code>p::Int = 2</code>: Order of the distance</li><li><code>normalized::Bool = true</code>: Normlize spectrum to sum to 1 (recommended)</li><li><code>transform::F = identity</code>: Optional function to apply to the spectrum, example <code>log1p</code> or <code>sqrt</code>. Must not produce negative values, so <code>log</code> is not a good idea. The function is applied like this: <code>transform.(x1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L206-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchOptimalTransportDistance" href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchOptimalTransportDistance{DT, AT &lt;: Tuple, KWT &lt;: NamedTuple} &lt;: AbstractWelchDistance</code></pre><p>Calculates the Wasserstein distance between two signals by estimating a Welch periodogram of each.</p><p><strong>Arguments:</strong></p><ul><li><code>distmat::DT</code>: you may provide a matrix array for this</li><li><code>args::AT = ()</code>: Options to the Welch function</li><li><code>kwargs::KWT = NamedTuple()</code>: Options to the Welch function</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L187-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.discrete_grid_transportcost-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any,Any}} where T" href="#SpectralDistances.discrete_grid_transportcost-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any,Any}} where T"><code>SpectralDistances.discrete_grid_transportcost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_grid_transportcost(x::AbstractVector{T}, y::AbstractVector{T}, p = 2, tol=sqrt(eps(T)); inplace=false) where T</code></pre><p>Calculate the optimal-transport cost between two vectors that are assumed to have the same support, with sorted and equdistant support points.</p><p>The calculated cost corresponds to the following</p><pre><code class="language-julia">D = [abs2((i-j)/(n-1)) for i in 1:n, j in 1:n] # note the 1/(n-1)
Γ = discrete_grid_transportplan(x, y)
dot(Γ, D)</code></pre><ul><li>´p´ is the power of the distance</li><li>´inplace<code>if true,</code>x` is overwritten.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L731-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T" href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_grid_transportplan(x::AbstractVector{T}, y::AbstractVector{T}, tol=sqrt(eps(T)); inplace=false) where T</code></pre><p>Calculate the optimal-transport plan between two vectors that are assumed to have the same support, with sorted support points.</p><ul><li>´inplace<code>if true,</code>x` is overwritten.</li><li>It&#39;s possible to supply keyword argument <code>g</code> to provide preallocated memory for the transport plan. Make sure it&#39;s all zeros if you do.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L692-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.distmat-Tuple{Any,AbstractArray{T,1} where T}" href="#SpectralDistances.distmat-Tuple{Any,AbstractArray{T,1} where T}"><code>SpectralDistances.distmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distmat(dist::Any, e::AbstractArray{T,1} where T; normalize, kwargs...) -&gt; LinearAlgebra.Symmetric
</code></pre><p>Compute the symmetric, pairwise distance matrix using the specified distance.</p><ul><li><code>normalize</code>: set to true to normalize distances such that the diagonal is zero. This is useful for distances that are not true distances due to <code>d(x,y) ≠ 0</code> such as the <a href="#SpectralDistances.OptimalTransportRootDistance"><code>OptimalTransportRootDistance</code></a></li></ul><p>This function uses multiple threads if available and copies the distance object to each thread in case it stores an internal cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L360-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.distmat_euclidean" href="#SpectralDistances.distmat_euclidean"><code>SpectralDistances.distmat_euclidean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distmat_euclidean(e1::AbstractVector, e2::AbstractVector, p = 2)</code></pre><p>The euclidean distance matrix between two vectors of complex numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.distmat_euclidean!" href="#SpectralDistances.distmat_euclidean!"><code>SpectralDistances.distmat_euclidean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distmat_euclidean!(D, e1::AbstractVector, e2::AbstractVector, p = 2) = begin</code></pre><p>In-place version</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain-Tuple{Any}" href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain(d::AbstractDistance)</code></pre><pre><code class="language-julia">domain(d::Any) -&gt; Discrete
</code></pre><p>Return the domain of the distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L322-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}" href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain_transform(d::AbstractDistance, e)</code></pre><p>Change domain of roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.precompute" href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precompute(d::AbstractDistance, As, threads=true)</code></pre><p>Perform computations that only need to be donce once when several pairwise distances are to be computed</p><p><strong>Arguments:</strong></p><ul><li><code>As</code>: A vector of models</li><li><code>threads</code>: Us multithreading? (true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/losses.jl#L599-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ConvOptimalTransportDistance" href="#SpectralDistances.ConvOptimalTransportDistance"><code>SpectralDistances.ConvOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConvOptimalTransportDistance &lt;: AbstractDistance</code></pre><p>Distance between matrices caluclated using <a href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a>. This type automatically creates a workspace object that is reused between invocations. Functions that internally performs threaded computations copy this object to each thread, but if manual threading is performed, this must be handled manually, e.g.:</p><pre><code class="language-julia">using ThreadTools
dists = [deepcopy(dist) for _ in 1:Threads.nthreads()]
D = tmap(eachindex(X)) do i
    evaluate(dists[Threads.threadid()], Q, X[i]; kwargs...)
end</code></pre><p>It&#39;s important to tune the two parameters below, see the docstring for <a href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a> for more help.</p><ul><li><p>To get sharp barycenters, a smaller β around 0.001 is recommended.</p></li><li><p>To get smooth distance profiles (<a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{#s541,T} where T where #s541&lt;:OptimalTransportRootDistance,TimeVaryingAR,TimeVaryingAR}"><code>distance_profile</code></a>), a slightly higher β than for barycenters is recommended.  β around 0.01-0.05 should do fine.</p></li><li><p><code>β = 0.001</code></p></li><li><p><code>dynamic_floor = -10.0</code></p></li><li><p><code>invariant_axis::Int = 0</code> If this is set to 1 or 2, the distance will be approximately invariant to translations along the invariant axis. As an example, to be invariant to a spectrogram being shifted slightly in time, set <code>invariant_axis = 2</code>.</p></li></ul><p>See also <a href="#SpectralDistances.SlidingConvOptimalTransportDistance"><code>SlidingConvOptimalTransportDistance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L613-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SCWorkspace-Tuple{Any,Any,Any}" href="#SpectralDistances.SCWorkspace-Tuple{Any,Any,Any}"><code>SpectralDistances.SCWorkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SCWorkspace(A, B, β)</code></pre><p>Workspace object for <a href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a>. Manually construct this in order to save allocations between consequtive calls to the solver.</p><p><strong>Arguments:</strong></p><ul><li><code>A</code>: The first matrix</li><li><code>B</code>: The second matrix</li><li><code>β</code>: the regularization parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L406-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SlidingConvOptimalTransportDistance" href="#SpectralDistances.SlidingConvOptimalTransportDistance"><code>SpectralDistances.SlidingConvOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SlidingConvOptimalTransportDistance</code></pre><p>Similar to <a href="#SpectralDistances.ConvOptimalTransportDistance"><code>ConvOptimalTransportDistance</code></a> but lets the shorter signal slide across the longer signal and returns the minimum distance. Equivalent to calling</p><pre><code class="language-julia">minimum(distance_profile(d::ConvOptimalTransportDistance, a, b; kwargs...))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L669-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.IPOT" href="#SpectralDistances.IPOT"><code>SpectralDistances.IPOT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Γ, u, v = IPOT(C, a, b; β=1, iters=1000)</code></pre><p>The Inexact Proximal point method for exact Optimal Transport problem (IPOT) (Sinkhorn-like) algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>. <code>β</code> does not have to go to 0 for this alg to return the optimal distance, in fact, if β is set too low, this alg will encounter numerical problems.</p><p>A Fast Proximal Point Method for Computing Exact Wasserstein Distance Yujia Xie, Xiangfeng Wang, Ruijia Wang, Hongyuan Zha https://arxiv.org/abs/1802.04307</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.mask_filter" href="#SpectralDistances.mask_filter"><code>SpectralDistances.mask_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mask_filter(X::Matrix, th=0.25)
mask_filter!(Y, X=Y, th=0.25)</code></pre><p>Mask out parts of a spectrogram that only contains impulsive noise. ´th ∈ (0,1) determines the amount of masking, a higher value masks out more. This function is to be applied after something like <a href="#SpectralDistances.normalize_spectrogram-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T"><code>normalize_spectrogram</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L797-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.normalize_spectrogram-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T" href="#SpectralDistances.normalize_spectrogram-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T"><code>SpectralDistances.normalize_spectrogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_spectrogram(S, dynamic_floor = default_dynamic_floor(S))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L715-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn(C, a, b; β=1e-1, iters=1000)</code></pre><p>The Sinkhorn algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. This function is relatively slow, see also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> <a href="#SpectralDistances.IPOT"><code>IPOT</code></a> and <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> for faster algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>SpectralDistances.sinkhorn_convolutional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sinkhorn_convolutional(A::AbstractMatrix, B::AbstractMatrix; β = 0.001, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L574-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_convolutional-Union{Tuple{T}, Tuple{SCWorkspace{T},AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where T" href="#SpectralDistances.sinkhorn_convolutional-Union{Tuple{T}, Tuple{SCWorkspace{T},AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where T"><code>SpectralDistances.sinkhorn_convolutional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sinkhorn_convolutional(w::SCWorkspace{T}, A::AbstractMatrix, B::AbstractMatrix; β = 0.01, τ = 1 / eps(T), iters = 1000, tol = 1.0e-6, ϵ = eps(T) ^ 2, verbose = false, initUV = true) where T</code></pre><p>Calculate the entropically regularizaed Sinkhorn distance between two matrices where the ground cost is squared euclidean. This function uses an efficient convolutional algorithm and is much more efficient than the corresponding <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> in this special case.</p><p>This function spends most of its time doing matrix multiplications. You may want to tune <code>BLAS.set_num_threads</code> in order to maximize performance. 1-2 threads is often best, especially if you thread outside of calls to this function.</p><p><strong>Arguments:</strong></p><ul><li><code>w</code>: workspace object</li><li><code>A</code>: The first matrix</li><li><code>B</code>: The second matrix</li><li><code>β</code>: regularization parameter. To get smooth distance profiles (<a href="../time/#SlidingDistancesBase.distance_profile-Tuple{TimeDistance{#s541,T} where T where #s541&lt;:OptimalTransportRootDistance,TimeVaryingAR,TimeVaryingAR}"><code>distance_profile</code></a>), a slightly higher β than for barycenters is recommended.  β around 0.01 should do fine.</li><li><code>τ</code>: stabilization parameter</li><li><code>iters</code>: maximum number of iterations</li><li><code>tol</code>: tolerance (change in oen of the dual variables)</li><li><code>ϵ</code>: other stabilization parameter</li><li><code>verbose</code>: print stuff?</li><li><code>initUV</code>: if true, initializes dual variables in <code>w</code> to one. It can be useful to set this to false if you have a good initial guess (warm start). Set the corresponding <code>w.U, w.V</code> to provide the initial guess.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L434-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same as <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> but operates in-place to save memory allocations. This function has higher performance than <code>sinkhorn_log</code>, but might not work as well with AD libraries.</p><p>This function can be made completely allocation free with the interface     sinkhorn_log(w::SinkhornLogWorkspace{T}, C, a, b; kwargs...)</p><p>The <code>sinkhorn_log!</code> solver also accepts a keyword argument <code>check_interval = 20</code> that determines how often the convergence criteria is checked. If <code>β</code> is large, the algorithm might converge very fast and you can save some iterations by reducing the check interval. If <code>β</code> is small and the algorithm requires many iterations, a larger number saves you from computing the check too often.</p><p>The workspace <code>w</code> is created linke this: <code>w = SinkhornLogWorkspace(FloatType, length(a), length(b))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn_log(C, a, b; β=1e-1, iters=1000, tol=1e-8)</code></pre><p>The Sinkhorn algorithm (log-stabilized). <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> for a faster implementation operating in-place, and <a href="#SpectralDistances.IPOT"><code>IPOT</code></a> for a potentially more exact solution.</p><p>When this function is being differentiated, warnings about inaccurate solutions are turned off. You may choose to manually asses the error in the constrains by <code>ea, eb = SpectralDistances.ot_error(Γ, a, b)</code>.</p><p>The IPOT algorithm: https://arxiv.org/pdf/1610.06519.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}" href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>SpectralDistances.sinkhorn_unbalanced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn_unbalanced(C, a, b, divergence; β=1e-1, iters=1000, tol=1e-8)</code></pre><p>The Unbalanced Sinkhorn algorithm (log-stabilized). <code>C</code> is the cost matrix and <code>a,b</code> are vectors that <em>are not required to sum to one</em>.</p><p>Ref: &quot;Sinkhorn Divergences for Unbalanced Optimal Transport&quot; https://arxiv.org/abs/1910.12958 Makes use of <a href="https://github.com/ericphanson/UnbalancedOptimalTransport.jl">UnbalancedOptimalTransport.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/sinkhorn.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ot_jump-Tuple{Any,Any,Any}" href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ot_jump(D, P1, P2)</code></pre><p>Solve the optimal transport problem using JuMP. This function is only available if <code>using JuMP, GLPK</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>D</code>: Distance matrix</li><li><code>P1</code>: Weight vector 1</li><li><code>P2</code>: Weight vector 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/6bda72db3f605c5fe453443d59b0709c5acef550/src/jump.jl#L3-L12">source</a></section></article><h2 id="Details-1"><a class="docs-heading-anchor" href="#Details-1">Details</a><a class="docs-heading-anchor-permalink" href="#Details-1" title="Permalink"></a></h2><p>Transport-based distances may require some tuning parameters to be set for the solvers. The available solvers are</p><ul><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>: not recommended due to numerical issues, but this is the most commonly cited algorithm.</li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a>: better numerical stability than the standard.</li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a>: in-place version that is faster, but some AD libraries might not like it (often the default if no solver is provided).</li><li><a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>sinkhorn_unbalanced</code></a>: this solver accepts a divergence that penalizes creation/destruction of mass. It thus handles measure of different masses and can choose to create/destroy mass instead of transporting it.</li><li><a href="#SpectralDistances.IPOT"><code>IPOT</code></a> Finds exact solution (without entropy regularization), requires β around 0.1-1.</li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>ot_jump</code></a>: exact solution using JuMP, requires <code>using JuMP, GLPK</code> before it becomes available.</li><li><a href="@ref"><code>ot_convex</code></a>: exact solution using <a href="https://www.juliaopt.org/Convex.jl/stable/">Convex.jl</a>, requires <code>using Convex, GLPK</code> before it becomes available.</li><li><a href="#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a>: applicable only to 2D grids, but is very efficient in this case. <a href="#SpectralDistances.ConvOptimalTransportDistance"><code>ConvOptimalTransportDistance</code></a> is the corresponding distance type.</li></ul><h3 id="Providing-solver-and-options-1"><a class="docs-heading-anchor" href="#Providing-solver-and-options-1">Providing solver and options</a><a class="docs-heading-anchor-permalink" href="#Providing-solver-and-options-1" title="Permalink"></a></h3><pre><code class="language-julia">options = (solver=sinkhorn_log!, tol=1e-6, iters=100_000)
distance = OptimalTransportRootDistance(domain=Continuous(), p=1, β=0.001)
SpectralDistances.evaluate(distance, model1, model2; options...)</code></pre><h3 id="Maximum-performance-1"><a class="docs-heading-anchor" href="#Maximum-performance-1">Maximum performance</a><a class="docs-heading-anchor-permalink" href="#Maximum-performance-1" title="Permalink"></a></h3><p>This solver <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> can be made completely allocation free with the interface</p><pre><code class="language-julia">sinkhorn_log(w::SinkhornLogWorkspace{T}, C, a, b; kwargs...)</code></pre><p>The workspace <code>w</code> is created linke this:</p><pre><code class="language-julia">w = SinkhornLogWorkspace(eltype(a), length(a), length(b))</code></pre><p>This will save you both allocations and time if called multiple times, especially important if you intend to make use of multiple threads. For multiple threads, make sure to create one workspace for each thread.</p><p>The <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> solver also accepts a keyword argument <code>check_interval = 20</code> that determines how often the convergence criteria is checked. If <code>β</code> is large, the algorithm might converge very fast and you can save some iterations by reducing the check interval. If <code>β</code> is small and the algorithm requires many iterations, a larger number saves you from computing the check too often.</p><p>See also inplace functions</p><ul><li><a href="#SpectralDistances.distmat_euclidean!"><code>distmat_euclidean!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ltimodels/">« Models and root manipulations</a><a class="docs-footer-nextpage" href="../time/">Time-Frequency distances »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 2 July 2020 08:43">Thursday 2 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
