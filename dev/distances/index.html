<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distances · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li class="is-active"><a class="tocitem" href>Distances</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#A-full-example-1"><span>A full example</span></a></li><li><a class="tocitem" href="#Using-Welch-periodograms-1"><span>Using Welch periodograms</span></a></li><li><a class="tocitem" href="#Gradients-1"><span>Gradients</span></a></li><li><a class="tocitem" href="#Unbalanced-transport-1"><span>Unbalanced transport</span></a></li><li><a class="tocitem" href="#Function-reference-1"><span>Function reference</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li><li><a class="tocitem" href="#Details-1"><span>Details</span></a></li></ul></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distances</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distances</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/distances.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Distances-1"><a class="docs-heading-anchor" href="#Distances-1">Distances</a><a class="docs-heading-anchor-permalink" href="#Distances-1" title="Permalink"></a></h1><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>The following is a reference for all the distances defined in this package. Once a distance object is defined, it can be evaluated in one of two ways, defined by the  <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> interface</p><pre><code class="language-julia">dist = DistanceType(options)
d = evaluate(d, x1, x2; kwargs...) # keyword arguments are used to control the solvers for some transport-based distances
d = dist(x1, x2) # A shorter syntax for calling the distance</code></pre><p><strong>Note:</strong> All distances return the distance raised to the power <code>p</code>, thus <code>RationalOptimalTransportDistance(p=2)(x1,x2) == W₂(x1,x2)^2</code> where <code>W₂</code> denotes the Wasserstein distance of order 2.</p><p>Before we proceed, we list a number of classes of distances that are available</p><ul><li><a href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a></li><li><a href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a></li><li><a href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a></li><li><a href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a></li><li><a href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a></li><li><a href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a></li><li><a href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a></li><li><a href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a></li><li><a href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a></li><li><a href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a></li><li><a href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportRootDistance"><code>SpectralDistances.OptimalTransportRootDistance</code></a></li><li><a href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a></li><li><a href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a></li><li><a href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a></li></ul><p>Some of these distances operate directly on signals, these are</p><pre><code class="language-none">EnergyDistance
ModelDistance
SpectralDistances.AbstractWelchDistance</code></pre><p>Of these, <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> is a bit special, works like this</p><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ModelDistance" href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelDistance{D &lt;: AbstractDistance} &lt;: AbstractSignalDistance</code></pre><p>A model distance operates on signals and works by fitting an LTI model to the signals before calculating the distance. The distance between the LTI models is defined by the field <code>distance</code>. This is essentially a wrapper around the inner distance that handles the fitting of a model to the signals. How the model is fit is determined by <code>fitmethod</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>fitmethod::</code><a href="../ltimodels/#SpectralDistances.FitMethod"><code>FitMethod</code></a>: <a href="../ltimodels/#SpectralDistances.LS"><code>LS</code></a>, <a href="../ltimodels/#SpectralDistances.TLS"><code>TLS</code></a> or <a href="../ltimodels/#SpectralDistances.PLR"><code>PLR</code></a></li><li><code>distance::D</code>: The inner distance between the models</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances
innerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)
dist = ModelDistance(TLS(na=30), innerdistance)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L48-L63">source</a></section></article><p>The inner distance in <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> can be any <a href="#SpectralDistances.AbstractRationalDistance"><code>AbstractRationalDistance</code></a>. The options are</p><pre><code class="language-none">DiscretizedRationalDistance
RationalCramerDistance
RationalOptimalTransportDistance
SpectralDistances.AbstractCoefficientDistance
SpectralDistances.AbstractRootDistance</code></pre><p>These distances operate on LTI models. Some operate on the coefficients of the models</p><pre><code class="language-none">CoefficientDistance</code></pre><p>and some operate on the roots of the models</p><pre><code class="language-none">EuclideanRootDistance
HungarianRootDistance
KernelWassersteinRootDistance
OptimalTransportRootDistance</code></pre><h2 id="A-full-example-1"><a class="docs-heading-anchor" href="#A-full-example-1">A full example</a><a class="docs-heading-anchor-permalink" href="#A-full-example-1" title="Permalink"></a></h2><p>To use the <a href="#SpectralDistances.OptimalTransportRootDistance"><code>OptimalTransportRootDistance</code></a> and let it operate on signals, we may construct our distance object as follows</p><pre><code class="language-julia-repl">julia&gt; innerdistance = OptimalTransportRootDistance(domain=Continuous(), β=0.005, p=2)
OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.005, 2, nothing)

julia&gt; dist = ModelDistance(TLS(na=10), innerdistance)
ModelDistance{OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing},TLS}(TLS(10, 0.0), OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.005, 2, nothing))

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
0.020900305881628594

julia&gt; dist = ModelDistance(LS(na=2), innerdistance);

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
0.0005678342162688203

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.00407322855228585</code></pre><h2 id="Using-Welch-periodograms-1"><a class="docs-heading-anchor" href="#Using-Welch-periodograms-1">Using Welch periodograms</a><a class="docs-heading-anchor-permalink" href="#Using-Welch-periodograms-1" title="Permalink"></a></h2><p>We can calculate the Wasserstein distance between spectra estimated using the Welch method like so</p><pre><code class="language-julia-repl">julia&gt; dist = WelchOptimalTransportDistance(p=2)
WelchOptimalTransportDistance{Nothing,Tuple{},NamedTuple{(),Tuple{}}}(nothing, (), NamedTuple(), 2)

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
0.0003535845316060714

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
8.823043208878249e-5

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.00029130696022822513</code></pre><h2 id="Gradients-1"><a class="docs-heading-anchor" href="#Gradients-1">Gradients</a><a class="docs-heading-anchor-permalink" href="#Gradients-1" title="Permalink"></a></h2><p>Some distances will allow you to propagate gradients through them. Below is an example using Zygote and the <a href="#SpectralDistances.OptimalTransportRootDistance"><code>OptimalTransportRootDistance</code></a></p><pre><code class="language-julia">using Zygote
Zygote.@nograd rand # Currently needed woraround
x1 = SpectralDistances.bp_filter(randn(100000), (0.1,0.3))  # Create two signals
x2 = SpectralDistances.bp_filter(randn(100000), (0.1,0.2))
fm = LS(na=10)      # LS is the best supported fitmethod for gradients

dist = ModelDistance(fm,OptimalTransportRootDistance(domain = Continuous()))      # Since we&#39;re measureing distance between signals, we wrap the distance in a ModelDistance</code></pre><pre><code class="language-none">ModelDistance{OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing},LS}(LS(10, 0.01), OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Nothing}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.01, 2, nothing))</code></pre><pre><code class="language-julia-repl">julia&gt; dist(x1,x2)
0.027235323880123966

julia&gt; ∇x1 = Zygote.gradient(x-&gt;real(evaluate(dist,x,x2)), x1)[1] # The call to real is a workaround for a Zygote bug
100000-element Array{Float64,1}:
  3.7941886583343173e-6
 -1.1432199189232572e-5
  1.1478231035920261e-5
 -1.5136927772373006e-5
  1.1005764826205785e-5
 -1.9363520276059635e-5
  1.1180874806529159e-5
 -2.222183588789598e-5
  3.974322670971006e-6
 -2.5128611110977215e-6
  ⋮
  2.1251308019700997e-6
 -7.620799881547004e-6
 -1.2178382792914463e-5
  1.076396830130313e-5
 -1.2636532102811444e-6
  1.6310837403546995e-5
 -1.594438043138127e-5
  6.951128303328147e-6
 -1.490294399838832e-5</code></pre><p>The differentiation takes some time, but it should be fast enough to be generally useful for gradient-based learning of autoencoders etc. The following is a benchmark performed on an old laptop without GPU (the distances are not yet tested on GPUs)</p><pre><code class="language-julia">@btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$x2)), $x1);
#  134.965 ms (107566 allocations: 134.77 MiB)</code></pre><p>with a precomputed reference model, it goes even faster</p><pre><code class="language-julia">m2 = fm(x2)
m2 = change_precision(Float64, m2) # Tihs step is important for performance
@btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$m2)), $x1);
#  80.200 ms (103437 allocations: 69.62 MiB)</code></pre><p>The same benchmarks performed on a 2019 desktop computer yields the following timings</p><pre><code class="language-julia">julia&gt; @btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$x2)), $x1);
  45.926 ms (107748 allocations: 136.18 MiB)

julia&gt; @btime Zygote.gradient(x-&gt;real(evaluate($dist,x,$m2)), $x1);
  25.120 ms (103619 allocations: 71.03 MiB)</code></pre><h2 id="Unbalanced-transport-1"><a class="docs-heading-anchor" href="#Unbalanced-transport-1">Unbalanced transport</a><a class="docs-heading-anchor-permalink" href="#Unbalanced-transport-1" title="Permalink"></a></h2><p>There are situations in which one would like to avoid fully transporting all mass between two measures. A few such cases are</p><ul><li>The two measures do not have the same mass. In this case, the standard, balanced, optimal-transport problem is unfeasible.</li><li>Energy is somehow lost or added to one spectra in a way that should not be accounted for by transport. This would be the case if<ul><li>Spectral energy is absorbed by a channel through which a signal is propagated. In this case it would not make sense to try to transport mass from the other spectrum away from the absorbed (dampended) frequency.</li><li>Spectral energy is added by a noise source. This energy should ideally not be considered for transport and should rather be destroyed.</li></ul></li></ul><p>For situations like this, an <code>AbstractDivergence</code> can be supplied to the <code>OptimalTransportRootDistance</code>. This divergence specifies how expensive it is to create or destroy mass in the spectra. The available divergences are listed in <a href="https://ericphanson.github.io/UnbalancedOptimalTransport.jl/stable/public_api/#Divergences-1">the docs of UnbalancedOptimalTransport.jl</a>, to which we outsource the solving of the unbalanced problem. For convenience, the wrapper <a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>sinkhorn_unbalanced</code></a> is available to interface the unbalanced solver in the same way as the solvers from this package are interfaced.</p><pre><code class="language-julia-repl">julia&gt; using DSP

julia&gt; fm = LS(na = 10);

julia&gt; m1 = fm(filtfilt(ones(10), [10], randn(1000)));
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists. Consider prefiltering the signal or decreasing the regularization factor.
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/ltimodels.jl:68

julia&gt; m2 = fm(filtfilt(ones(5), [5], randn(1000)));
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists. Consider prefiltering the signal or decreasing the regularization factor.
└ @ SpectralDistances ~/work/SpectralDistances.jl/SpectralDistances.jl/src/ltimodels.jl:68

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=Balanced())
OptimalTransportRootDistance{Continuous,typeof(identity),typeof(simplex_residueweight),Balanced}(Continuous(), identity, SpectralDistances.simplex_residueweight, 0.01, 1, Balanced())

julia&gt; d1 = evaluate(dist,m1,m2)
0.13548131784016387

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(1.0));

julia&gt; d2 = evaluate(dist,m1,m2)
0.12916171188372763

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(10.0));

julia&gt; d3 = evaluate(dist,m1,m2)
0.13481793967995637

julia&gt; dist = OptimalTransportRootDistance(domain = Continuous(), p=1, divergence=KL(0.01));

julia&gt; d4 = evaluate(dist,m1,m2)
0.029523569846449584

julia&gt; d1 &gt; d3 &gt; d2 &gt; d4
true</code></pre><p>When the distance is evaluated the second time, unbalanced transport is used. The <code>d2</code> should be equal to or smaller than <code>d1</code>. If we make the <code>KL</code> term larger, the distance approaches the balanced cost, and if we make it smaller, it becomes very cheap to create/destroy mass and less mass is transported.</p><p>The first case, where <code>divergence=Balanced()</code> was supplied, should be equivalent to not providing any divergence at all. In pratice results might differ slightly since a different solver implementation is used.</p><p>Currently, only distance calculations using unbalanced transport is supported. Barycenter calculations will currently ignore the divergence.</p><p>Below is an example in which the unbalanced transport between two systems is computed. The two systems do not have the same number of poles, and if destruction of mass is made cheap, not all mass is transported. The thickness of the lines indicate mass flow.</p><pre><code class="language-julia">using Plots
m1 = AR(Continuous(), [1, 0.1, 1.3])                        |&gt; change_precision(Float64)
m2 = AR(Continuous(), polyconv([1, 0.1, 1], [1, 0.1, 1.2])) |&gt; change_precision(Float64)
D  = SpectralDistances.distmat_euclidean(m1.pc, m2.pc)
w1, w2 = unitweight.((m1, m2))
figs = map([0.001, 0.01, 0.1]) do tv
    divergence = TV(tv)
    Γ, a, b = sinkhorn_unbalanced(D, w1, w2, divergence, β = 0.01)
    lineS   = 20Γ
    lineS[lineS.&lt;0.1] .= 0
    alphaS  = lineS ./ maximum(lineS)
    f       = scatter(m1.pc, legend = false, ms = 10, title = &quot;TV=$tv&quot;)
    scatter!(m2.pc, ms = 10)
    for (i, p1) in enumerate(m1.pc), (j, p2) in enumerate(m2.pc)
        coords = [p1, p2]
        plot!(
            real(coords),
            imag(coords),
            linewidth = lineS[i, j],
            alpha     = alphaS[i, j],
            color     = :black,
        )
    end
    f
end
plot(figs..., layout = (1, 3), ylims = (0.9, 1.2))</code></pre><pre><code class="language-none">┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283
┌ Warning: No strict ticks found
└ @ PlotUtils ~/.julia/packages/PlotUtils/10ojB/src/ticks.jl:283</code></pre><object type="text/html" data="../unbalanced_poles.html" style="width:100%;height:450px;"></object><h2 id="Function-reference-1"><a class="docs-heading-anchor" href="#Function-reference-1">Function reference</a><a class="docs-heading-anchor-permalink" href="#Function-reference-1" title="Permalink"></a></h2><ul><li><a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a></li><li><a href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a></li><li><a href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a></li><li><a href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a></li><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a></li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a></li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a></li><li><a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>SpectralDistances.sinkhorn_unbalanced</code></a></li></ul><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractDistance" href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The top level distance type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractRationalDistance" href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on rational transfer functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractSignalDistance" href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on signals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.BuresDistance" href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuresDistance &lt;: AbstractDistance</code></pre><p>Distance between pos.def. matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.CoefficientDistance" href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoefficientDistance{D, ID} &lt;: AbstractCoefficientDistance</code></pre><p>Distance metric based on model coefficients</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance between coeffs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscretizedRationalDistance" href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscretizedRationalDistance{WT, DT} &lt;: AbstractRationalDistance</code></pre><p>This distance discretizes the spectrum before performing the calculations.</p><p><strong>Arguments:</strong></p><ul><li><code>w::WT = LinRange(0.01, 0.5, 300)</code>: Frequency set</li><li><code>distmat::DT = distmat_euclidean(w, w)</code>: DESCRIPTION</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L156-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EnergyDistance" href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EnergyDistance &lt;: AbstractSignalDistance</code></pre><p><code>std(x1) - std(x2)</code> This distance can be added to a loss function to ensure that the energy in the two signals is the same. Some of the optimal transport-based distances are invariant to the energy in the signal, requiring this extra cost if that invariance is not desired. Combining distances is done by putting two or more in a tuple.     Usage: <code>combined_loss = (primary_distance, EnergyDistance())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L269-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EuclideanRootDistance" href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EuclideanRootDistance{D, A, F1, F2} &lt;: AbstractRootDistance</code></pre><p>Simple euclidean distance between roots of transfer functions</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>assignment::A =</code> <a href="../ltimodels/#SpectralDistances.SortAssignement"><code>SortAssignement</code></a><code>(imag)</code>: Determines how roots are assigned. An alternative is <code>HungarianAssignement</code></li><li><code>transform::F1 = identity</code>: DESCRIPTION</li><li><code>weight</code> : A function used to calculate weights for the induvidual root distances. A good option is <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a></li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L69-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.HungarianRootDistance" href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HungarianRootDistance{D, ID &lt;: Distances.PreMetric, F} &lt;: AbstractRootDistance</code></pre><p>Similar to <a href="#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> but does the pole assignment using the Hungarian method.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.KernelWassersteinRootDistance" href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KernelWassersteinRootDistance{D, F, DI} &lt;: AbstractRootDistance</code></pre><p>A kernel version of the root distance</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>λ::Float64 = 1.0</code>: Kernel precision, lower value means wider kernel.</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li><li><code>distance::DI = SqEuclidean()</code>: Inner distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.OptimalTransportHistogramDistance" href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimalTransportHistogramDistance{DT} &lt;: AbstractDistance</code></pre><p>Optimal transport between two histograms. If you pass two vectors to this distance two histograms will be computed automatically (<code>fit(Histogram,x)</code>). Pass two histograms to get better manual control.</p><p><strong>Arguments:</strong></p><ul><li><code>p::Int = 1</code>: order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.OptimalTransportRootDistance" href="#SpectralDistances.OptimalTransportRootDistance"><code>SpectralDistances.OptimalTransportRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimalTransportRootDistance{D, F1, F2, S} &lt;: AbstractRootDistance</code></pre><p>The Sinkhorn distance between roots. The weights are provided by <code>weight</code>, which defaults to <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>transform::F1 = identity</code>: Probably not needed.</li><li><code>weight::F2 =</code><a href="../ltimodels/#SpectralDistances.simplex_residueweight-Tuple{Any}"><code>simplex_residueweight</code></a>: A function used to calculate weights for the induvidual root distances.</li><li><code>β::Float64 = 0.01</code>: Amount of entropy regularization</li><li><code>p::Int = 2</code> : Order of the distance</li><li><code>divergence::S = nothing</code>: A divergence that penalizes creation and destruction of mass.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalCramerDistance" href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RationalCramerDistance{DT} &lt;: AbstractRationalDistance</code></pre><p>Similar to <code>RationalOptimalTransportDistance</code> but does not use inverse functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 2</code>: order</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L244-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalOptimalTransportDistance" href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RationalOptimalTransportDistance{DT, MT} &lt;: AbstractRationalDistance</code></pre><p>calculates the Wasserstein distance using the closed-form solution based on integrals and inverse cumulative functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 1</code>: order</li><li><code>magnitude::MT = Identity()</code>:</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchLPDistance" href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchLPDistance{AT &lt;: Tuple, KWT &lt;: NamedTuple, F} &lt;: AbstractWelchDistance</code></pre><p>Lᵖ distance between welch spectra, <code>mean(abs(x1-x2)^p)</code>.</p><p>#Arguments:</p><ul><li><code>args::AT = ()</code>: These are sent to <code>welch_pgram</code></li><li><code>kwargs::KWT = NamedTuple()</code>: These are sent to <code>welch_pgram</code></li><li><code>p::Int = 2</code>: Order of the distance</li><li><code>normalized::Bool = true</code>: Normlize spectrum to sum to 1 (recommended)</li><li><code>transform::F = identity</code>: Optional function to apply to the spectrum, example <code>log1p</code> or <code>sqrt</code>. Must not produce negative values, so <code>log</code> is not a good idea. The function is applied like this: <code>transform.(x1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L190-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchOptimalTransportDistance" href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchOptimalTransportDistance{DT, AT &lt;: Tuple, KWT &lt;: NamedTuple} &lt;: AbstractWelchDistance</code></pre><p>Calculates the Wasserstein distance between two signals by estimating a Welch periodogram of each.</p><p><strong>Arguments:</strong></p><ul><li><code>distmat::DT</code>: you may provide a matrix array for this</li><li><code>args::AT = ()</code>: Options to the Welch function</li><li><code>kwargs::KWT = NamedTuple()</code>: Options to the Welch function</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L171-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T" href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_grid_transportplan(x::AbstractVector{T}, y::AbstractVector{T}, tol=sqrt(eps(T))) where T</code></pre><p>Calculate the optimal-transport plan between two vectors that are assumed to have the same support, with sorted support points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L608-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain-Tuple{Any}" href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain(d::AbstractDistance)</code></pre><pre><code class="language-julia">domain(d::Any) -&gt; Discrete
</code></pre><p>Return the domain of the distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L280-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}" href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain_transform(d::AbstractDistance, e)</code></pre><p>Change domain of roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.precompute" href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precompute(d::AbstractDistance, As, threads=true)</code></pre><p>Perform computations that only need to be donce once when several pairwise distances are to be computed</p><p><strong>Arguments:</strong></p><ul><li><code>As</code>: A vector of models</li><li><code>threads</code>: Us multithreading? (true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/losses.jl#L536-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.IPOT-Tuple{Any,Any,Any}" href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = IPOT(C, a, b; β=1, iters=1000)</code></pre><p>The Inexact Proximal point method for exact Optimal Transport problem (IPOT) (Sinkhorn-like) algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>. <code>β</code> does not have to go to 0 for this alg to return the optimal distance, in fact, if β is set too low, this alg will encounter numerical problems.</p><p>A Fast Proximal Point Method for Computing Exact Wasserstein Distance Yujia Xie, Xiangfeng Wang, Ruijia Wang, Hongyuan Zha https://arxiv.org/abs/1802.04307</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/sinkhorn.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn(C, a, b; β=1e-1, iters=1000)</code></pre><p>The Sinkhorn algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. This function is relatively slow, see also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> <a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> and <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> for faster algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/sinkhorn.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same as <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> but operates in-place to save memory allocations. This function has higher performance than <code>sinkhorn_log</code>, but might not work as well with AD libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/sinkhorn.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn_log(C, a, b; β=1e-1, iters=1000, tol=1e-8)</code></pre><p>The Sinkhorn algorithm (log-stabilized). <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> for a faster implementation operating in-place, and <a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> for a potentially more exact solution.</p><p>When this function is being differentiated, warnings about inaccurate solutions are turned off. You may choose to manually asses the error in the constrains by <code>ea, eb = SpectralDistances.ot_error(Γ, a, b)</code>.</p><p>The IPOT algorithm: https://arxiv.org/pdf/1610.06519.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/sinkhorn.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}" href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>SpectralDistances.sinkhorn_unbalanced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Γ, u, v = sinkhorn_unbalanced(C, a, b, divergence; β=1e-1, iters=1000, tol=1e-8)</code></pre><p>The Unbalanced Sinkhorn algorithm (log-stabilized). <code>C</code> is the cost matrix and <code>a,b</code> are vectors that <em>are not required to sum to one</em>.</p><p>Ref: &quot;Sinkhorn Divergences for Unbalanced Optimal Transport&quot; https://arxiv.org/abs/1910.12958 Makes use of <a href="https://github.com/ericphanson/UnbalancedOptimalTransport.jl">UnbalancedOptimalTransport.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/sinkhorn.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ot_jump-Tuple{Any,Any,Any}" href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ot_jump(D, P1, P2)</code></pre><p>Solve the optimal transport problem using JuMP. This function is only available if <code>using JuMP, GLPK</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>D</code>: Distance matrix</li><li><code>P1</code>: Weight vector 1</li><li><code>P2</code>: Weight vector 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/ca57137f37013e7f0b485053642eea3185ae85fa/src/jump.jl#L3-L12">source</a></section></article><h2 id="Details-1"><a class="docs-heading-anchor" href="#Details-1">Details</a><a class="docs-heading-anchor-permalink" href="#Details-1" title="Permalink"></a></h2><p>Transport-based distances may require some tuning parameters to be set for the solvers. The available solvers are</p><ul><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>: not recommended due to numerical issues, but this is the most commonly cited algorithm.</li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a>: better numerical stability than the standard.</li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a>: in-place version that is faster, but some AD libraries might not like it (often the default if no solver is provided).</li><li><a href="#SpectralDistances.sinkhorn_unbalanced-NTuple{4,Any}"><code>sinkhorn_unbalanced</code></a>: this solver accepts a divergence that penalizes creation/destruction of mass. It thus handles measure of different masses and can choose to create/destroy mass instead of transporting it.</li><li><a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> Finds exact solution (without entropy regularization), requires β around 0.1-1.</li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>ot_jump</code></a>: exact solution using JuMP, requires <code>using JuMP, GLPK</code> before it becomes available.</li><li><a href="@ref"><code>ot_convex</code></a>: exact solution using <a href="https://www.juliaopt.org/Convex.jl/stable/">Convex.jl</a>, requires <code>using Convex, GLPK</code> before it becomes available.</li></ul><h3 id="Providing-solver-and-options-1"><a class="docs-heading-anchor" href="#Providing-solver-and-options-1">Providing solver and options</a><a class="docs-heading-anchor-permalink" href="#Providing-solver-and-options-1" title="Permalink"></a></h3><pre><code class="language-julia">options = (solver=sinkhorn_log!, tol=1e-6, iters=100_000)
distance = OptimalTransportRootDistance(domain=Continuous(), p=1, β=0.001)
SpectralDistances.evaluate(distance, model1, model2; options...)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ltimodels/">« Models and root manipulations</a><a class="docs-footer-nextpage" href="../time/">Time-Frequency distances »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 15 April 2020 05:45">Wednesday 15 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
