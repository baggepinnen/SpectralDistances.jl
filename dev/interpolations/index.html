<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolations and Barycenters · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li><a class="tocitem" href="../distances/">Distances</a></li><li><a class="tocitem" href="../time/">Time-Frequency distances</a></li><li class="is-active"><a class="tocitem" href>Interpolations and Barycenters</a><ul class="internal"><li><a class="tocitem" href="#Barycenters-1"><span>Barycenters</span></a></li><li><a class="tocitem" href="#Barycentric-coordiantes-1"><span>Barycentric coordiantes</span></a></li><li><a class="tocitem" href="#K-Barycenters-1"><span>K-Barycenters</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../taskview/">Task View</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolations and Barycenters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolations and Barycenters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/interpolations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolations-and-Barycenters-1"><a class="docs-heading-anchor" href="#Interpolations-and-Barycenters-1">Interpolations and Barycenters</a><a class="docs-heading-anchor-permalink" href="#Interpolations-and-Barycenters-1" title="Permalink"></a></h1><p>Some distances distance define the existence of a shortest path, a <em>geodesic</em>. An interpolation is essentially a datapoint on that shortest path. We provide some functionality to interpolate between different spectra and models under transport-based metrics.</p><p>Below is an example usage of interpolations. We initially create two random systems, we then define the distance under which to interpolate and then calculate the frequency response for some different values of the interpolation parameter <span>$t \in (0,1)$</span></p><pre><code class="language-julia">using SpectralDistances, ControlSystems, Distances, Plots, Random
plotly()
Random.seed!(0)

n = 4
r1 = complex.(-0.01 .+ 0.001randn(3), 2randn(3))
r1 = ContinuousRoots([r1; conj.(r1)])

r2 = complex.(-0.01 .+ 0.001randn(3), 2randn(3))
r2 = ContinuousRoots([r2; conj.(r2)])

r1,r2 = normalize_energy.((r1, r2))

A1 = AR(r1)
A2 = AR(r2)

##
fig1   = plot()
t      = 0.1
dist   = RationalOptimalTransportDistance(domain=Continuous(), p=2, interval=(0., exp10(1.01)))
interp = SpectralDistances.interpolator(dist, A1, A2)
w      = exp10.(LinRange(-1.5, 1, 300))
for t = LinRange(0, 1, 7)
    Φ = clamp.(interp(w,t), 1e-10, 100)
    plot!(w, sqrt.(Φ), xscale=:log10, yscale=:log10, line_z = t, lab=&quot;&quot;, xlabel=&quot;&quot;, title=&quot;W_2&quot;, ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)
end

rdist  = EuclideanRootDistance(domain = Continuous(), p = 2)
interp = SpectralDistances.interpolator(rdist, A1, A2, normalize=false)
fig2   = plot()
for t = LinRange(0, 1, 7)
    Φ = interp(w,t)
    plot!(w, sqrt.(Φ), xscale=:log10, yscale=:log10, line_z = t, lab=&quot;&quot;, xlabel=&quot;&quot;, title=&quot;RD&quot;, ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)
end

fig3 = plot()
Φ1   = bode(tf(A1), w)[1][:]
Φ2   = bode(tf(A2), w)[1][:]
for t = LinRange(0, 1, 7)
    plot!(w, (1-t).*Φ1 .+ t.*Φ2, xscale=:log10, yscale=:log10, line_z = t, lab=&quot;&quot;, xlabel=&quot;Frequency&quot;, title=&quot;L_2&quot;, ylims=(1e-3, 1e1), colorbar=false, l=(1,), c=:viridis)
end

fig = plot(fig1, fig2, fig3, layout=(3,1))</code></pre><object type="text/html" data="../interpolation.html" style="width:100%;height:450px;"></object><h2 id="Barycenters-1"><a class="docs-heading-anchor" href="#Barycenters-1">Barycenters</a><a class="docs-heading-anchor-permalink" href="#Barycenters-1" title="Permalink"></a></h2><p>A barycenter is a generalization the the arithmetic mean to metrics other than the Euclidean. A barycenter between models is calculated like this</p><pre><code class="language-julia">bc = barycenter(distance, models)</code></pre><p>It can be useful to provide some options to the solvers:</p><pre><code class="language-julia">options = (solver=sinkhorn_log!, tol=1e-8, iters=1_000_000, γ=0.0, uniform=true, inneriters=500_000, innertol=1e-6)
distance = OptimalTransportRootDistance(domain=Continuous(), p=2, β=0.01, weight=simplex_residueweight)
bc = barycenter(distance, models; options...)</code></pre><p>We can plot the barycenters:</p><pre><code class="language-julia">using SpectralDistances, ControlSystems, Plots
models   = examplemodels(3)
distance = OptimalTransportRootDistance(domain=Continuous())
bc       = barycenter(distance, models)
w        = exp10.(LinRange(-0.5, 0.5, 350)) # Frequency vector
G        = tf.(models) # Convert models to transfer functions from ControlSystems.jl
plot()
bodeplot!.(G, Ref(w), plotphase=false, lab=&quot;Input models&quot;, linestyle=:auto)
bodeplot!(tf(bc), w, plotphase=false, lab=&quot;Barycenter&quot;, xscale=:identity, c=:green)</code></pre><object type="text/html" data="../barycenter.html" style="width:100%;height:450px;"></object><h3 id="Barycenters-between-spectrograms-1"><a class="docs-heading-anchor" href="#Barycenters-between-spectrograms-1">Barycenters between spectrograms</a><a class="docs-heading-anchor-permalink" href="#Barycenters-between-spectrograms-1" title="Permalink"></a></h3><p>We can also calculate a barycenter between spectrograms (or arbitrary matrices) using an efficient convolutional method. The most important parameter to tune in order to get a good result, apart from the regularization parameter <code>β</code>, is the <code>dynamic_floor</code>. This parameter determines where (in log space) the floor of the PSD is. This serves as a denoising, why the barycenter appears with a very dark background in the image below.</p><pre><code class="language-julia">using SpectralDistances, DSP, Plots
N     = 24_000
t     = 1:N
f     = range(0.8, stop=1.2, length=N)
y1    = sin.(t .* f) .+ 0.1 .* randn.()
y2    = sin.(t .* reverse(f .+ 0.5)) .+ 0.1 .* randn.()
S1,S2 = spectrogram.((y1,y2), 1024)

A = [S1,S2]
β = 0.0001     # Regularization parameter (higher implies more smoothing and a faster, more stable solution)
λ = [0.5, 0.5] # Barycentric coordinates (must sum to 1)
B = barycenter_convolutional(A, β=β, tol=1e-6, iters=2000, ϵ=1e-100, dynamic_floor=-2)
plot(
    plot(S1, title=&quot;S1&quot;),
    plot(B, title=&quot;Barycenter&quot;),
    plot(S2, title=&quot;S2&quot;),
    layout=(1,3),
    colorbar=false
)</code></pre><object type="text/html" data="../barycenter_sg.html" style="width:100%;height:450px;"></object><p>Note that in order to calculate the barycenter, the sum of each input spectrogram is normalized.</p><p>This function works for any vector of matrices as long as all entries are positive and each matrix has an equal sum.</p><p>For a more thourogh example, see <a href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/examples/whistle.jl">whistle.jl</a>.</p><h3 id="Trade-off-between-frequency-and-time-1"><a class="docs-heading-anchor" href="#Trade-off-between-frequency-and-time-1">Trade off between frequency and time</a><a class="docs-heading-anchor-permalink" href="#Trade-off-between-frequency-and-time-1" title="Permalink"></a></h3><p>There is currently no way of having different costs between transport in time and transport along the frequency axis other than to change the resolution of the spectrogram.</p><h2 id="Barycentric-coordiantes-1"><a class="docs-heading-anchor" href="#Barycentric-coordiantes-1">Barycentric coordiantes</a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordiantes-1" title="Permalink"></a></h2><p>The inverse problem to that of finding a barycenter is that of finding the barycentric coordinates λ of a query point <span>$Q$</span>, such that the resulting barycenter is as close as possible to the query point. Given a set of rational spectra <span>$\left\{ G_i \right\}$</span>, a nonlinear projection of a spectrum <span>$Q$</span> onto this set can be obtained by solving the following nested optimization problem</p><div>\[\begin{aligned}
  λ &amp;= \argmin_{\bar{λ}} \, W\big(Q,  Q^*(\bar{λ})\big)\\
  Q^*(\bar{λ}) &amp;= \argmin_{\bar{Q}} \sum_i \bar{λ}_i W(G_i, \bar{Q})
\end{aligned}\]</div><p>where <span>$λ$</span> are the barycentric coordinates belonging to the probability simplex. Problems of this type are sometimes referred to as <a href="https://perso.liris.cnrs.fr/nicolas.bonneel/WassersteinBarycentricCoordinates/WBC_lowres.pdf">histogram regression</a>.</p><p>A nonlinear projection onto a basis consisting of spectra can be useful for, e.g., spectral dictionary learning, basis pursuit, topic modelling, denoising and detection. The function <a href="#SpectralDistances.barycentric_coordinates"><code>barycentric_coordinates</code></a> is available for select distances:</p><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycentric_coordinates" href="#SpectralDistances.barycentric_coordinates"><code>SpectralDistances.barycentric_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">λ = barycentric_coordinates(pl, ql, p, q; options, kwargs...)</code></pre><p>Compute the barycentric coordinates <code>λ</code> such that sum(λᵢ W(pᵢ,q) for i in eachindex(p)) is minimized.</p><p>This function works best with the <code>sinkhorn_log!</code> solver, a large β (around 1) and small tolerance. These are set using <code>kwargs...</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pl</code>: Atoms in measures <code>p</code>, vector, length <code>n_measures</code>, of matrices of size <code>n_dims × n_atoms</code></li><li><code>ql</code>: Atoms in measure <code>q</code></li><li><code>p</code>: Measures <code>p</code>, a matrix of weight vectors, size <code>n_atoms × n_measures</code> that sums to 1</li><li><code>q</code>: the veight vector for measure <code>q</code>, length is <code>n_atoms</code></li><li><code>options</code>: For the Optim solver. Defaults are <code>options = Optim.Options(store_trace=false, show_trace=false, show_every=0, iterations=20, allow_f_increases=true, time_limit=100, x_tol=1e-5, f_tol=1e-6, g_tol=1e-6, f_calls_limit=0, g_calls_limit=0)</code></li><li><code>solver</code>: = <a href="../distances/#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> solver</li><li><code>tol</code>:    = 1e-7 tolerance</li><li><code>β</code>:      = 0.1 entropy regularization. This function works best with rather large regularization, hence the large default value.</li><li><code>kwargs</code>: these are sent to the solver algorithm.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances, ControlSystems, Optim
models = examplemodels(10)

d = OptimalTransportRootDistance(
    domain = SpectralDistances.Continuous(),
    p      = 2,
    weight = residueweight,
    β      = 0.01,
)
Xe = barycenter(d, models, solver=sinkhorn_log!)

G = tf.(models)
plot()
pzmap!.(G)
pzmap!(tf(Xe), m=:c, title=&quot;Barycenter OptimalTransportRootDistance&quot;, lab=&quot;BC&quot;)

options = Optim.Options(store_trace       = true,
                        show_trace        = false,
                        show_every        = 1,
                        iterations        = 50,
                        allow_f_increases = true,
                        time_limit        = 100,
                        x_tol             = 1e-7,
                        f_tol             = 1e-7,
                        g_tol             = 1e-7,
                        f_calls_limit     = 0,
                        g_calls_limit     = 0)


method = LBFGS()
λ = barycentric_coordinates(d, models, Xe, method,
    options = options,
    solver  = sinkhorn_log!,
    robust  = true,
    uniform = true,
    tol     = 1e-6,
)
bar(λ, title=&quot;Barycentric coorinates&quot;)

G = tf.(models)
plot()
pzmap!.(G, lab=&quot;&quot;)
pzmap!(tf(Xe), m = :c, title = &quot;Barycenter OptimalTransportRootDistance&quot;, lab = &quot;BC&quot;)
# It&#39;s okay if the last system dot does not match the barycenter exactly, there are limited models to choose from.
pzmap!(G[argmax(λ)], m = :c, lab = &quot;Largest bc coord&quot;, legend = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L194-L261">source</a></section><section><div><pre><code class="language-julia">barycentric_coordinates(d::ConvOptimalTransportDistance, X::Vector{&lt;:AbstractMatrix}, q::AbstractMatrix; method = LBFGS(), kwargs...)</code></pre><p>Calculate the barycentric coordinates of a vector of matrices <code>X</code> using the convolutional method.</p><p><strong>Arguments:</strong></p><ul><li><code>q</code>: Query matrix</li><li><code>method</code>: The optimizer from Optim</li><li><code>kwargs</code>: Are sent to <a href="../distances/#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a></li></ul><p><strong>Optim options</strong></p><p>The default options are</p><pre><code class="language-none">options = Optim.Options(
        store_trace       = true,
        show_trace        = false,
        show_every        = 1,
        iterations        = 10,
        allow_f_increases = false,
        time_limit        = 150,
        x_tol             = 1e-3,
        f_tol             = 1e-3,
        g_tol             = 1e-4,
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L1036-L1061">source</a></section></article><p>Below is an example that assumes that you have access to a vector with a signal called <code>y</code> and the corresponding sample rate <code>fs</code> (in this example, we use the <code>y</code> constructed in the previous example. In the example, we simply use one of the input spectra as query point. This way, we know what barycentric coordinates we expect</p><pre><code class="language-julia">using SpectralDistances, DSP, Plots
models = map(DSP.arraysplit(y1, 8*512, 0)) do y
    spectrogram(y, 512, fs = 24_000, window=hanning)
end

matrices = s1.(normalize_spectrogram.(models))

β      = 0.01
dist   = ConvOptimalTransportDistance(β=β)
Q      = matrices[2] # Use the second spectrogram as query
λ, res = barycentric_coordinates(dist, matrices, Q)
plot(
    bar(λ, title=&quot;Barycentric coordinates&quot;, lab=&quot;&quot;),
    plot(spectrogram(y1, window=hanning), title=&quot;Signal&quot;),
    heatmap(Q, title=&quot;Query point&quot;)
)</code></pre><object type="text/html" data="../barycentric_coords_sg.html" style="width:100%;height:450px;"></object><h2 id="K-Barycenters-1"><a class="docs-heading-anchor" href="#K-Barycenters-1">K-Barycenters</a><a class="docs-heading-anchor-permalink" href="#K-Barycenters-1" title="Permalink"></a></h2><p>Below, we show an example of how one can run the K-barycenter algorithm on a collection of sound signals. <code>sounds</code> is expected to be of type <code>Vector{Vector{T}}</code>. The example further assumes that there is a vector of <code>labels::Vector{Int}</code> that contain the true classes of the datapoints, which you do not have in an unsupervised setting.</p><pre><code class="language-julia">using SpectralDistances, ControlSystems
fitmethod = TLS(na=12)
models = SpectralDistances.fitmodel.(fitmethod, sounds)
G = tf.(models) # Convert to transfer functions for visualization etc.

##
using Clustering
dist = OptimalTransportRootDistance(domain=Continuous(), β=0.01, weight=simplex_residueweight)
@time clusterresult = SpectralDistances.kbarycenters(
    dist,
    models,
    n_classes, # number of clusters
    seed       = :rand,
    solver     = sinkhorn_log!,
    tol        = 2e-6,
    innertol   = 2e-6,
    iters      = 100000,
    inneriters = 100000,
    verbose    = true,
    output     = :best,
    uniform    = true,
    kiters     = 10
)

bc,ass = clusterresult.barycenters, clusterresult.assignments

# Visualize results
using MLBase, Plots.PlotMeasures, AudioClustering
newass,perm = AudioClustering.associate_clusters(labels,ass)
classinds   = 1:n_classes
yt          = (classinds, [label_strings[findfirst(labels .== i)] for i in classinds])

@show mean(labels .== newass)
cm = confusmat(n_classes,labels,newass)
heatmap(cm./sum(cm,dims=2), xlabel=&quot;Cluster assignment&quot;,ylabel=&quot;Best matching class&quot;, color=:viridis)
anns = [(reverse(ci.I)..., text(val,12,:gray)) for (ci,val) in zip(CartesianIndices(cm)[:], vec(cm))]
annotate!(anns)
yticks!(yt)
xticks!(yt, xrotation=45)
current()</code></pre><p>The figure should look like the last figure in <a href="http://arxiv.org/abs/2004.09152">the paper</a>.</p><ul><li><a href="#SpectralDistances.BCCWorkspace-Union{Tuple{T}, Tuple{Array{#s544,1} where #s544&lt;:AbstractArray{T,2},Any,Any}} where T"><code>SpectralDistances.BCCWorkspace</code></a></li><li><a href="#SpectralDistances.ISA"><code>SpectralDistances.ISA</code></a></li><li><a href="#SpectralDistances.barycenter"><code>SpectralDistances.barycenter</code></a></li><li><a href="#SpectralDistances.barycenter-Tuple{Array{#s65,1} where #s65&lt;:AbstractArray,Any}"><code>SpectralDistances.barycenter</code></a></li><li><a href="#SpectralDistances.barycenter-Tuple{EuclideanRootDistance,AbstractArray{T,1} where T}"><code>SpectralDistances.barycenter</code></a></li><li><a href="#SpectralDistances.barycenter_convolutional-Union{Tuple{TK}, Tuple{T}, Tuple{BCWorkspace{T,TK},AbstractArray{#s534,1} where #s534&lt;:(AbstractArray{T,2} where T)}, Tuple{BCWorkspace{T,TK},AbstractArray{#s535,1} where #s535&lt;:(AbstractArray{T,2} where T),Union{Array{#s537,1} where #s537&lt;:Union{Float32, Float64}, #s536} where #s536&lt;:FillArrays.Fill}} where TK where T"><code>SpectralDistances.barycenter_convolutional</code></a></li><li><a href="#SpectralDistances.barycenter_convolutional"><code>SpectralDistances.barycenter_convolutional</code></a></li><li><a href="#SpectralDistances.barycentric_coordinates"><code>SpectralDistances.barycentric_coordinates</code></a></li><li><a href="#SpectralDistances.barycentric_coordinates-Union{Tuple{T}, Tuple{Any,Any,Any,AbstractArray{T,1}}, Tuple{Any,Any,Any,AbstractArray{T,1},Any}} where T"><code>SpectralDistances.barycentric_coordinates</code></a></li><li><a href="#SpectralDistances.barycentric_coordinates-Tuple{ConvOptimalTransportDistance,Array{#s541,1} where #s541&lt;:(AbstractArray{T,2} where T),AbstractArray{T,2} where T}"><code>SpectralDistances.barycentric_coordinates</code></a></li><li><a href="#SpectralDistances.embedding-Tuple{Type{Array{T,1} where T},Any,Vararg{Any,N} where N}"><code>SpectralDistances.embedding</code></a></li><li><a href="#SpectralDistances.interpolator-Tuple{RationalOptimalTransportDistance,Any,Any}"><code>SpectralDistances.interpolator</code></a></li><li><a href="#SpectralDistances.kbarycenters-Tuple{OptimalTransportRootDistance,Array{#s8,1} where #s8&lt;:SpectralDistances.AbstractModel,Any}"><code>SpectralDistances.kbarycenters</code></a></li><li><a href="#SpectralDistances.kbarycenters-Tuple{Any,Any,Any}"><code>SpectralDistances.kbarycenters</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.interpolator-Tuple{RationalOptimalTransportDistance,Any,Any}" href="#SpectralDistances.interpolator-Tuple{RationalOptimalTransportDistance,Any,Any}"><code>SpectralDistances.interpolator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolator(d, A1, A2)
</code></pre><p>Perform displacement interpolation between two models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/interpolations.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.BCCWorkspace-Union{Tuple{T}, Tuple{Array{#s544,1} where #s544&lt;:AbstractArray{T,2},Any,Any}} where T" href="#SpectralDistances.BCCWorkspace-Union{Tuple{T}, Tuple{Array{#s544,1} where #s544&lt;:AbstractArray{T,2},Any,Any}} where T"><code>SpectralDistances.BCCWorkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BCCWorkspace(X::Vector{&lt;:AbstractMatrix{T}}, L, β) where T</code></pre><p>Create a workspace cache for <a href="#SpectralDistances.barycentric_coordinates"><code>barycentric_coordinates</code></a> with the convolutional distance.</p><p><strong>Arguments:</strong></p><ul><li><code>X</code>: Input matrices</li><li><code>L</code>: Number of iterations</li><li><code>β</code>: Regularization factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L927-L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ISA" href="#SpectralDistances.ISA"><code>SpectralDistances.ISA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ISA(X, w = nothing; iters = 100, printerval = typemax(Int))</code></pre><p>Iterative swapping algorithm from &quot;On the Computation of Wasserstein barycenters&quot;, Giovanni Puccetti et al.</p><p><strong>Arguments:</strong></p><ul><li><code>X</code>: vector of d×k matrices where d is dimension and k number of atoms</li><li><code>w</code>: weights. See the files <code>test_barycenter.jl</code> for different uses.</li><li><code>iters</code>: maximum number of iterations</li><li><code>printerval</code>: print this often</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L420-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycenter" href="#SpectralDistances.barycenter"><code>SpectralDistances.barycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barycenter(d::OptimalTransportRootDistance, models; normalize = true, kwargs...)</code></pre><pre><code class="language-julia">barycenter(d, models)
barycenter(d, models, λ; normalize, uniform, solver, kwargs...)
</code></pre><p><strong>Approximately</strong> calculate the barycenter supported on the same number of atoms as the number of poles in the models.</p><p>The solver can be selected by providing a keword argument, example: <code>solver=IPOT</code>.</p><p>Uses the algorithms from <a href="https://arxiv.org/pdf/1310.4375.pdf">&quot;Fast Computation of Wasserstein Barycenters&quot;</a></p><p><strong>Example:</strong></p><pre><code class="language-julia">models = examplemodels(10)

d = OptimalTransportRootDistance(domain=SpectralDistances.Continuous(),p=2, weight=residueweight, β=0.01)
Xe = barycenter(d, models, solver=sinkhorn_log!, uniform=true)

plot()
pzmap!.(models)
pzmap!(tf(Xe), m=:c, title=&quot;Barycenter OptimalTransportRootDistance&quot;, lab=&quot;BC&quot;)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>models</code>: vector of AR models</li><li><code>normalize</code>: make sure weights sum to 1</li><li><code>kwargs</code>: are sent to the solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L47-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycenter-Tuple{Array{#s65,1} where #s65&lt;:AbstractArray,Any}" href="#SpectralDistances.barycenter-Tuple{Array{#s65,1} where #s65&lt;:AbstractArray,Any}"><code>SpectralDistances.barycenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barycenter(X::Vector{&lt;:AbstractArray}, λ)</code></pre><p>Calculate the weighted barycenter for point clouds in <code>X</code>. Each <code>X[i]</code> has the shame <code>n_dims × n_atoms</code> <code>λ</code> is the weight vector that should sum to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycenter-Tuple{EuclideanRootDistance,AbstractArray{T,1} where T}" href="#SpectralDistances.barycenter-Tuple{EuclideanRootDistance,AbstractArray{T,1} where T}"><code>SpectralDistances.barycenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barycenter(d::EuclideanRootDistance, models::AbstractVector, [λ])</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia">models = examplemodels(10)

Xe = barycenter(EuclideanRootDistance(domain=SpectralDistances.Continuous(),p=2), models)

G = tf.(models)
plot()
pzmap!.(G)
pzmap!(tf(Xe), m=:c, title=&quot;Barycenter EuclideanRootDistance&quot;)
current()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L98-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycenter_convolutional" href="#SpectralDistances.barycenter_convolutional"><code>SpectralDistances.barycenter_convolutional</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">barycenter_convolutional(models::Vector{&lt;:DSP.Periodograms.TFR}, λ = Fill(1 / length(models), length(models)); dynamic_floor = default_dynamic_floor(models), kwargs...)</code></pre><p>Covenience function for the calculation of spectrograms. This function transforms the spectrograms to log-power and adjusts the floor to <code>dynamic_floor</code>, followed by a normalization to sum to 1.</p><p>This function will be called if <a href="#SpectralDistances.barycenter"><code>barycenter</code></a> is called with <a href="../distances/#SpectralDistances.ConvOptimalTransportDistance"><code>ConvOptimalTransportDistance</code></a> as first argument.</p><p><strong>Arguments:</strong></p><ul><li><code>dynamic_floor</code>: Sets the floor of the spectrogram in log-domain, i.e., all values below this will be truncated. The default value is based on a quantile of the spectrogram powers. If your spectrograms are mostly low entropy, you can try to increase this number to get sharper results.</li><li><code>kwargs</code>: Same as for the base method</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances, DSP, Plots
N     = 24_000
t     = 1:N
f     = range(0.8, stop=1.2, length=N)
y1    = sin.(t .* f) .+ 0.1 .* randn.()
y2    = sin.(t .* reverse(f .+ 0.5)) .+ 0.1 .* randn.()
S1,S2 = spectrogram.((y1,y2), 1024)

A = [S1,S2]
β = 0.0001     # Regularization parameter (higher implies more smoothing and a faster, more stable solution)
λ = [0.5, 0.5] # Barycentric coordinates (must sum to 1)
B = barycenter_convolutional(A, β=β, tol=1e-6, iters=200, ϵ=1e-100, dynamic_floor=-2)
plot(plot(S1, title=&quot;S1&quot;), plot(B, title=&quot;Barycenter&quot;), plot(S2, title=&quot;S2&quot;), layout=(1,3), colorbar=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L770-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycenter_convolutional-Union{Tuple{TK}, Tuple{T}, Tuple{BCWorkspace{T,TK},AbstractArray{#s534,1} where #s534&lt;:(AbstractArray{T,2} where T)}, Tuple{BCWorkspace{T,TK},AbstractArray{#s535,1} where #s535&lt;:(AbstractArray{T,2} where T),Union{Array{#s537,1} where #s537&lt;:Union{Float32, Float64}, #s536} where #s536&lt;:FillArrays.Fill}} where TK where T" href="#SpectralDistances.barycenter_convolutional-Union{Tuple{TK}, Tuple{T}, Tuple{BCWorkspace{T,TK},AbstractArray{#s534,1} where #s534&lt;:(AbstractArray{T,2} where T)}, Tuple{BCWorkspace{T,TK},AbstractArray{#s535,1} where #s535&lt;:(AbstractArray{T,2} where T),Union{Array{#s537,1} where #s537&lt;:Union{Float32, Float64}, #s536} where #s536&lt;:FillArrays.Fill}} where TK where T"><code>SpectralDistances.barycenter_convolutional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barycenter_convolutional(A, [λ]; β = 0.01, iters = 1000, tol = 1e-9, ϵ = 1e-90, verbose = false)</code></pre><p>Convolutional barycenters.</p><p>´β<code>is the regularization and</code>λ<code>(optional) are the weights (barycentric coordinates). To reuse allocated space between successive calls, use the &quot;workspace&quot; method from the example below.</code>ϵ` is a truncation parameter for numerical stability.</p><pre><code class="language-julia">a1      = zeros(10, 10)
a1[2,2] = 1
a2      = zeros(10, 10)
a2[6,6] = 1
A       = [a1,a2]
β       = 0.01
λ       = [0.5, 0.5] # Barycentric coordinates, must sum to 1
w       = BCWorkspace(A, β)
b       = barycenter_convolutional(w,A,λ)
plot(heatmap(a1), heatmap(a2), heatmap(b))</code></pre><p>Ref: J. Solomon, F. de Goes, G. Peyré, M. Cuturi, A. Butscher, A. Nguyen, T. Du, L. Guibas. Convolutional Wasserstein Distances: Efficient Optimal Transportation on Geometric Domains.  2015 https://people.csail.mit.edu/jsolomon/assets/convolutional_w2.compressed.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L644-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycentric_coordinates-Tuple{ConvOptimalTransportDistance,Array{#s541,1} where #s541&lt;:(AbstractArray{T,2} where T),AbstractArray{T,2} where T}" href="#SpectralDistances.barycentric_coordinates-Tuple{ConvOptimalTransportDistance,Array{#s541,1} where #s541&lt;:(AbstractArray{T,2} where T),AbstractArray{T,2} where T}"><code>SpectralDistances.barycentric_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barycentric_coordinates(d::ConvOptimalTransportDistance, X::Vector{&lt;:AbstractMatrix}, q::AbstractMatrix; method = LBFGS(), kwargs...)</code></pre><p>Calculate the barycentric coordinates of a vector of matrices <code>X</code> using the convolutional method.</p><p><strong>Arguments:</strong></p><ul><li><code>q</code>: Query matrix</li><li><code>method</code>: The optimizer from Optim</li><li><code>kwargs</code>: Are sent to <a href="../distances/#SpectralDistances.sinkhorn_convolutional-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>sinkhorn_convolutional</code></a></li></ul><p><strong>Optim options</strong></p><p>The default options are</p><pre><code class="language-none">options = Optim.Options(
        store_trace       = true,
        show_trace        = false,
        show_every        = 1,
        iterations        = 10,
        allow_f_increases = false,
        time_limit        = 150,
        x_tol             = 1e-3,
        f_tol             = 1e-3,
        g_tol             = 1e-4,
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L1036-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.barycentric_coordinates-Union{Tuple{T}, Tuple{Any,Any,Any,AbstractArray{T,1}}, Tuple{Any,Any,Any,AbstractArray{T,1},Any}} where T" href="#SpectralDistances.barycentric_coordinates-Union{Tuple{T}, Tuple{Any,Any,Any,AbstractArray{T,1}}, Tuple{Any,Any,Any,AbstractArray{T,1},Any}} where T"><code>SpectralDistances.barycentric_coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">λ = barycentric_coordinates(pl, ql, p, q; options, kwargs...)</code></pre><p>Compute the barycentric coordinates <code>λ</code> such that sum(λᵢ W(pᵢ,q) for i in eachindex(p)) is minimized.</p><p>This function works best with the <code>sinkhorn_log!</code> solver, a large β (around 1) and small tolerance. These are set using <code>kwargs...</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pl</code>: Atoms in measures <code>p</code>, vector, length <code>n_measures</code>, of matrices of size <code>n_dims × n_atoms</code></li><li><code>ql</code>: Atoms in measure <code>q</code></li><li><code>p</code>: Measures <code>p</code>, a matrix of weight vectors, size <code>n_atoms × n_measures</code> that sums to 1</li><li><code>q</code>: the veight vector for measure <code>q</code>, length is <code>n_atoms</code></li><li><code>options</code>: For the Optim solver. Defaults are <code>options = Optim.Options(store_trace=false, show_trace=false, show_every=0, iterations=20, allow_f_increases=true, time_limit=100, x_tol=1e-5, f_tol=1e-6, g_tol=1e-6, f_calls_limit=0, g_calls_limit=0)</code></li><li><code>solver</code>: = <a href="../distances/#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> solver</li><li><code>tol</code>:    = 1e-7 tolerance</li><li><code>β</code>:      = 0.1 entropy regularization. This function works best with rather large regularization, hence the large default value.</li><li><code>kwargs</code>: these are sent to the solver algorithm.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances, ControlSystems, Optim
models = examplemodels(10)

d = OptimalTransportRootDistance(
    domain = SpectralDistances.Continuous(),
    p      = 2,
    weight = residueweight,
    β      = 0.01,
)
Xe = barycenter(d, models, solver=sinkhorn_log!)

G = tf.(models)
plot()
pzmap!.(G)
pzmap!(tf(Xe), m=:c, title=&quot;Barycenter OptimalTransportRootDistance&quot;, lab=&quot;BC&quot;)

options = Optim.Options(store_trace       = true,
                        show_trace        = false,
                        show_every        = 1,
                        iterations        = 50,
                        allow_f_increases = true,
                        time_limit        = 100,
                        x_tol             = 1e-7,
                        f_tol             = 1e-7,
                        g_tol             = 1e-7,
                        f_calls_limit     = 0,
                        g_calls_limit     = 0)


method = LBFGS()
λ = barycentric_coordinates(d, models, Xe, method,
    options = options,
    solver  = sinkhorn_log!,
    robust  = true,
    uniform = true,
    tol     = 1e-6,
)
bar(λ, title=&quot;Barycentric coorinates&quot;)

G = tf.(models)
plot()
pzmap!.(G, lab=&quot;&quot;)
pzmap!(tf(Xe), m = :c, title = &quot;Barycenter OptimalTransportRootDistance&quot;, lab = &quot;BC&quot;)
# It&#39;s okay if the last system dot does not match the barycenter exactly, there are limited models to choose from.
pzmap!(G[argmax(λ)], m = :c, lab = &quot;Largest bc coord&quot;, legend = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L194-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.embedding-Tuple{Type{Array{T,1} where T},Any,Vararg{Any,N} where N}" href="#SpectralDistances.embedding-Tuple{Type{Array{T,1} where T},Any,Vararg{Any,N} where N}"><code>SpectralDistances.embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding([::Type{Vector}], m, [full=true])</code></pre><p>Returns a <code>Vector/Matrix</code> containing the roots of <code>m</code>. <code>full</code> indicates whether or not to use all poles or only one half-plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/barycenter.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.kbarycenters-Tuple{Any,Any,Any}" href="#SpectralDistances.kbarycenters-Tuple{Any,Any,Any}"><code>SpectralDistances.kbarycenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kbarycenters(X, p, k; seed = :rand, kiters = 10, verbose = false, output = :best, kwargs...)</code></pre><p>Clustering using K-barycenters. If you want to cluster spectra, consider the method that accepts models instead.</p><p><strong>Arguments:</strong></p><ul><li><code>X</code>: Support of input measures, Vector{Matrix} where each matrix is n<em>dims×n</em>atoms</li><li><code>p</code>: Weights of input measures Vector{Vector} where each matrix is of length n_atoms and should sum to 1.</li><li><code>k</code>: number of clusters</li><li><code>seed</code>: :rand or :eq</li><li><code>kiters</code>: number of iterations</li><li><code>verbose</code>: print stuff?</li><li><code>output</code>: output lowest cost clustering or :latest?</li><li><code>kwargs</code>: are sent to the inner solvers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/kbarycenters.jl#L22-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.kbarycenters-Tuple{OptimalTransportRootDistance,Array{#s8,1} where #s8&lt;:SpectralDistances.AbstractModel,Any}" href="#SpectralDistances.kbarycenters-Tuple{OptimalTransportRootDistance,Array{#s8,1} where #s8&lt;:SpectralDistances.AbstractModel,Any}"><code>SpectralDistances.kbarycenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kbarycenters(d::OptimalTransportRootDistance, models::Vector{&lt;:AbstractModel}, k; normalize = true, kwargs...)</code></pre><p>This function is only available if <code>using Clustering</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">clusterresult = kbarycenters(
    dist,
    models,
    k,         # number of clusters
    seed       = :rand,
    solver     = sinkhorn_log!,
    tol        = 2e-6,
    innertol   = 2e-6,
    iters      = 100000,
    inneriters = 100000,
    verbose    = true,
    output     = :best,
    uniform    = true,
    kiters     = 10
)</code></pre><p>The docs contain <a href="https://baggepinnen.github.io/SpectralDistances.jl/latest/interpolations/#K-Barycenters-1">a more detailed example</a></p><p><strong>Arguments:</strong></p><ul><li><code>models</code>: A vector of models</li><li><code>k</code>: number of clusters</li><li><code>normalize</code>: Whether or not to normalize the weight vectors (recommended)</li><li><code>kwargs</code>: are sent to inner solvers, (<code>solver,tol,iters</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/520c6453e07ea8d1b0bd7bf49ad87d78c17bc028/src/kbarycenters.jl#L129-L159">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../time/">« Time-Frequency distances</a><a class="docs-footer-nextpage" href="../plotting/">Plotting »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 8 August 2020 10:29">Saturday 8 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
